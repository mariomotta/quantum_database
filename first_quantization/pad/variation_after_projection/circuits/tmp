/Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf/lib/misc.py:46: H5pyDeprecationWarning: Using default_file_mode other than 'r' is deprecated. Pass the mode to h5py.File() instead.
  h5py.get_config().default_file_mode = 'a'
/Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/qiskit/aqua/__init__.py:86: DeprecationWarning: The package qiskit.aqua is deprecated. It was moved/refactored to qiskit-terra For more information see <https://github.com/Qiskit/qiskit-aqua/blob/main/README.md#migration-guide>
  warn_package('aqua', 'qiskit-terra')
/Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/qiskit/chemistry/__init__.py:170: DeprecationWarning: The package qiskit.chemistry is deprecated. It was moved/refactored to qiskit_nature (pip install qiskit-nature). For more information see <https://github.com/Qiskit/qiskit-aqua/blob/main/README.md#migration-guide>
  warn_package('chemistry', 'qiskit_nature', 'qiskit-nature')
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_hf_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = [['F',(0.0000,0.0000,0.0000)],['H',(0.0000,0.0000, dist)]],
                  basis = 'sto-6g',symmetry = 'coov',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/hf/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/hf_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/hf_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:32:48 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   0.500000000000 AA    0.000000000000   0.000000000000   0.944863062283 Bohr

nuclear repulsion = 9.52518979656
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:         4.21

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpbkvyzrcg
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpbkvyzrcg
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (E1y) = -0.542449098513258  LUMO (A1) = 1.06641683472435
Initial guess E= -98.6431706488635  |g|= 5.92553e-11
macro= 0  E= -98.6431706488635  delta_E= -7.10543e-14  |g|= 5.92553e-11  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-98.6431706488635  |g|= 5.92553e-11  total 2 KF 4 JK
converged SCF energy = -98.6431706488635

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpbkvyzrcg
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -98.6492586392853  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (3 JK  1 micro), CASSCF E = -98.649259227325  dE = -5.880397e-07  S^2 = 0.0000000
               |grad[o]|=0.000996  |grad[c]|= 0.0005598508699383355  |ddm|=1.43e-05
macro iter 2 (1 JK  1 micro), CASSCF E = -98.6492592273519  dE = -2.6915359e-11  S^2 = 0.0000000
               |grad[o]|=3.43e-06  |grad[c]|= 8.90228249604693e-06  |ddm|=4.72e-06
1-step CASSCF converged in 2 macro (4 JK 2 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99852367 1.9987067  1.99964162 1.99964162 0.00348639]
CASSCF energy = -98.6492592273519
CASCI E = -98.6492592273519  E(CI) = -30.6193134261933  S^2 = 0.0000000
/Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/qiskit/aqua/operators/legacy/op_converter.py:90: DeprecationWarning: The variable qiskit.aqua.aqua_globals is deprecated. It was moved/refactored to qiskit.utils.algorithm_globals (pip install qiskit-terra). For more information see <https://github.com/Qiskit/qiskit-aqua/blob/main/README.md#migration-guide>
  num_processes=aqua_globals.num_processes)
/Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/qiskit/aqua/components/optimizers/optimizer.py:49: DeprecationWarning: The package qiskit.aqua.components.optimizers is deprecated. It was moved/refactored to qiskit.algorithms.optimizers (pip install qiskit-terra). For more information see <https://github.com/Qiskit/qiskit-aqua/blob/main/README.md#migration-guide>
/Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/qiskit/aqua/components/optimizers/optimizer.py:49: DeprecationWarning: The package qiskit.aqua.components.optimizers is deprecated. It was moved/refactored to qiskit.algorithms.optimizers (pip install qiskit-terra). For more information see <https://github.com/Qiskit/qiskit-aqua/blob/main/README.md#migration-guide>
  warn_package('aqua.components.optimizers',
/Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/qiskit/aqua/algorithms/vq_algorithm.py:70: DeprecationWarning: The class qiskit.aqua.algorithms.VQAlgorithm is deprecated. It was moved/refactored to qiskit.algorithms.VariationalAlgorithm (pip install qiskit-terra). For more information see <https://github.com/Qiskit/qiskit-aqua/blob/main/README.md#migration-guide>
  warn_class('aqua.algorithms.VQAlgorithm',
/Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/qiskit/aqua/quantum_instance.py:135: DeprecationWarning: The class qiskit.aqua.QuantumInstance is deprecated. It was moved/refactored to qiskit.utils.QuantumInstance (pip install qiskit-terra). For more information see <https://github.com/Qiskit/qiskit-aqua/blob/main/README.md#migration-guide>
  warn_class('aqua.QuantumInstance',
/Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/qiskit/aqua/algorithms/eigen_solvers/eigen_solver.py:36: DeprecationWarning: The package qiskit.aqua.algorithms.eigen_solvers is deprecated. It was moved/refactored to qiskit.algorithms.eigen_solvers (pip install qiskit-terra). For more information see <https://github.com/Qiskit/qiskit-aqua/blob/main/README.md#migration-guide>
  warn_package('aqua.algorithms.eigen_solvers',
/Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_h2o_results_cascade.py:26: DeprecationWarning: Back-references to from Bit instances to their containing Registers have been deprecated. Instead, inspect Registers to find their contained Bits.
  qubits = [q.index for q in gate[1]]
original CI Hamiltonian matrix size .......... 225
after projection on GS irrep, matrix size .... 65
after projection on singlet, matrix size ..... 37
Ground state energy (orig)  -75.70522588044759
Ground state energy (pad)  -75.70522588044759
after padding, matrix size ................... 64
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_h2o_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

def geometry(d):
    z0 = 0.1177
    z1 = 0.47116
    y0 = 0.75545
    r0 = np.sqrt(y0**2+(z0+z1)**2)
    r  = d/r0
    return "O 0.0000 0.0000 {0}; H 0.0000 {1} -{2}; H 0.0000 -{1} -{2}".format(z0*r,y0*r,z1*r)

dist_list = [0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/h2o/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = geometry(dist),
                  basis = 'sto-6g',symmetry = 'c2v',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        perm = permute_orbitals(orb_info,nf=1,sort_occupied=['B2','B1','A1','A1'],sort_virtual=['A1','B1'])
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1,permutation=perm)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/h2o/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/h2o_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/h2o_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:33:50 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 3
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry C2v subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 O      0.000000000000   0.000000000000   0.135168467155 AA    0.000000000000   0.000000000000   0.255431383601 Bohr
[INPUT]  2 H      0.000000000000   0.867570250744  -0.541087298088 AA    0.000000000000   1.639470167726  -1.022506802867 Bohr
[INPUT]  3 H      0.000000000000  -0.867570250744  -0.541087298088 AA    0.000000000000  -1.639470167726  -1.022506802867 Bohr

nuclear repulsion = 8.00209964502083
point group symmetry = C2v
num. orbitals of irrep A1 = 4
num. orbitals of irrep B1 = 2
num. orbitals of irrep B2 = 1
number of shells = 5
number of NR pGTOs = 42
number of NR cGTOs = 7
basis = sto-6g
ecp = {}
CPU time:        72.27

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 B1 B2




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpcorc3gv9
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpcorc3gv9
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (B2) = -0.393117520839696  LUMO (A1) = 0.469291794570369
Initial guess E= -75.6567189616229  |g|= 1.57317e-10
macro= 0  E= -75.656718961623  delta_E= -2.84217e-14  |g|= 1.57317e-10  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-75.656718961623  |g|= 1.57317e-10  total 2 KF 4 JK
converged SCF energy = -75.656718961623

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 6o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpcorc3gv9
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -75.7281287235215  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -75.7281575696102  dE = -2.8846089e-05  S^2 = 0.0000000
               |grad[o]|=0.00239  |grad[c]|= 0.0008701747216560553  |ddm|=0.000147
macro iter 2 (3 JK  1 micro), CASSCF E = -75.7281579320228  dE = -3.6241264e-07  S^2 = 0.0000000
               |grad[o]|=0.000276  |grad[c]|= 9.192137565470445e-05  |ddm|=1.48e-05
macro iter 3 (1 JK  1 micro), CASSCF E = -75.7281579320289  dE = -6.0396133e-12  S^2 = 0.0000000
               |grad[o]|=1.93e-06  |grad[c]|= 3.2749626308109952e-06  |ddm|=2.92e-06
1-step CASSCF converged in 3 macro (8 JK 4 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99818905 1.95279617 1.99106696 1.9604311  0.05018045 0.04733627]
CASSCF energy = -75.7281579320289
CASCI E = -75.7281579320289  E(CI) = -22.7437590638221  S^2 = 0.0000000
original CI Hamiltonian matrix size .......... 225
after projection on GS irrep, matrix size .... 65
after projection on singlet, matrix size ..... 37
Ground state energy (orig)  -75.7281287235618
Ground state energy (pad)  -75.7281287235618
after padding, matrix size ................... 64
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_h2o_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

def geometry(d):
    z0 = 0.1177
    z1 = 0.47116
    y0 = 0.75545
    r0 = np.sqrt(y0**2+(z0+z1)**2)
    r  = d/r0
    return "O 0.0000 0.0000 {0}; H 0.0000 {1} -{2}; H 0.0000 -{1} -{2}".format(z0*r,y0*r,z1*r)

dist_list = [0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/h2o/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = geometry(dist),
                  basis = 'sto-6g',symmetry = 'c2v',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        perm = permute_orbitals(orb_info,nf=1,sort_occupied=['B2','B1','A1','A1'],sort_virtual=['A1','B1'])
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1,permutation=perm)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/h2o/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/h2o_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/h2o_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:34:59 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 3
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry C2v subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 O      0.000000000000   0.000000000000   0.159744552093 AA    0.000000000000   0.000000000000   0.301873453347 Bohr
[INPUT]  2 H      0.000000000000   1.025310296333  -0.639466806831 AA    0.000000000000   1.937555652767  -1.208417130661 Bohr
[INPUT]  3 H      0.000000000000  -1.025310296333  -0.639466806831 AA    0.000000000000  -1.937555652767  -1.208417130661 Bohr

nuclear repulsion = 6.7710073919407
point group symmetry = C2v
num. orbitals of irrep A1 = 4
num. orbitals of irrep B1 = 2
num. orbitals of irrep B2 = 1
number of shells = 5
number of NR pGTOs = 42
number of NR cGTOs = 7
basis = sto-6g
ecp = {}
CPU time:       140.78

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 B1 B2




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpr336yapb
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpr336yapb
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (B2) = -0.397951766204723  LUMO (A1) = 0.33292277271706
Initial guess E= -75.5521478952092  |g|= 6.71691e-08
macro= 0  E= -75.5521478952092  delta_E= -2.84217e-14  |g|= 6.71691e-08  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-75.5521478952092  |g|= 6.71691e-08  total 2 KF 4 JK
converged SCF energy = -75.5521478952092

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 6o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpr336yapb
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -75.665561063025  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -75.6655892368121  dE = -2.8173787e-05  S^2 = 0.0000000
               |grad[o]|=0.00293  |grad[c]|= 0.0007729501425167214  |ddm|=0.000131
macro iter 2 (3 JK  1 micro), CASSCF E = -75.665589687002  dE = -4.5018992e-07  S^2 = 0.0000000
               |grad[o]|=0.000373  |grad[c]|= 8.862802046823153e-05  |ddm|=1.54e-05
macro iter 3 (1 JK  1 micro), CASSCF E = -75.6655896870084  dE = -6.4375172e-12  S^2 = 0.0000000
               |grad[o]|=2.27e-06  |grad[c]|= 3.1975217028193765e-06  |ddm|=1.68e-06
1-step CASSCF converged in 3 macro (8 JK 4 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99824351 1.90098722 1.9916402  1.89893403 0.11156826 0.09862678]
CASSCF energy = -75.6655896870084
CASCI E = -75.6655896870084  E(CI) = -21.7447501650768  S^2 = 0.0000000
original CI Hamiltonian matrix size .......... 225
after projection on GS irrep, matrix size .... 65
after projection on singlet, matrix size ..... 37
Ground state energy (orig)  -75.66556106346874
Ground state energy (pad)  -75.66556106346874
after padding, matrix size ................... 64
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_h2o_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

def geometry(d):
    z0 = 0.1177
    z1 = 0.47116
    y0 = 0.75545
    r0 = np.sqrt(y0**2+(z0+z1)**2)
    r  = d/r0
    return "O 0.0000 0.0000 {0}; H 0.0000 {1} -{2}; H 0.0000 -{1} -{2}".format(z0*r,y0*r,z1*r)

dist_list = [0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/h2o/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = geometry(dist),
                  basis = 'sto-6g',symmetry = 'c2v',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        perm = permute_orbitals(orb_info,nf=1,sort_occupied=['B2','B1','A1','A1'],sort_virtual=['A1','B1'])
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1,permutation=perm)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/h2o/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/h2o_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/h2o_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:35:59 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 3
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry C2v subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 O      0.000000000000   0.000000000000   0.184320637030 AA    0.000000000000   0.000000000000   0.348315523092 Bohr
[INPUT]  2 H      0.000000000000   1.183050341923  -0.737846315574 AA    0.000000000000   2.235641137808  -1.394327458455 Bohr
[INPUT]  3 H      0.000000000000  -1.183050341923  -0.737846315574 AA    0.000000000000  -2.235641137808  -1.394327458455 Bohr

nuclear repulsion = 5.86820640634861
point group symmetry = C2v
num. orbitals of irrep A1 = 4
num. orbitals of irrep B1 = 2
num. orbitals of irrep B2 = 1
number of shells = 5
number of NR pGTOs = 42
number of NR cGTOs = 7
basis = sto-6g
ecp = {}
CPU time:       200.50

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 B1 B2




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp0kivcr95
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp0kivcr95
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.376164418904664  LUMO (A1) = 0.236272511093415
Initial guess E= -75.4205031995739  |g|= 8.9956e-08
macro= 0  E= -75.4205031995739  delta_E= 0  |g|= 8.9956e-08  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-75.4205031995739  |g|= 8.9956e-08  total 2 KF 4 JK
converged SCF energy = -75.4205031995739

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 6o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp0kivcr95
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -75.5910185441333  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -75.5910432312252  dE = -2.4687092e-05  S^2 = 0.0000000
               |grad[o]|=0.00373  |grad[c]|= 0.0007433852068104582  |ddm|=0.00012
macro iter 2 (3 JK  1 micro), CASSCF E = -75.5910436486415  dE = -4.1741635e-07  S^2 = 0.0000000
               |grad[o]|=0.000482  |grad[c]|= 7.926509651305309e-05  |ddm|=1.45e-05
macro iter 3 (1 JK  1 micro), CASSCF E = -75.5910436486458  dE = -4.3200998e-12  S^2 = 0.0000000
               |grad[o]|=2.71e-06  |grad[c]|= 2.361219203321278e-06  |ddm|=2.07e-06
1-step CASSCF converged in 3 macro (8 JK 4 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99856059 1.81012825 1.99331707 1.79026602 0.21821394 0.18951413]
CASSCF energy = -75.5910436486458
CASCI E = -75.5910436486458  E(CI) = -20.9840976046429  S^2 = 0.0000000
original CI Hamiltonian matrix size .......... 225
after projection on GS irrep, matrix size .... 65
after projection on singlet, matrix size ..... 37
Ground state energy (orig)  -75.59101854470997
Ground state energy (pad)  -75.59101854470997
after padding, matrix size ................... 64
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_h2o_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

def geometry(d):
    z0 = 0.1177
    z1 = 0.47116
    y0 = 0.75545
    r0 = np.sqrt(y0**2+(z0+z1)**2)
    r  = d/r0
    return "O 0.0000 0.0000 {0}; H 0.0000 {1} -{2}; H 0.0000 -{1} -{2}".format(z0*r,y0*r,z1*r)

dist_list = [0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/h2o/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = geometry(dist),
                  basis = 'sto-6g',symmetry = 'c2v',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        perm = permute_orbitals(orb_info,nf=1,sort_occupied=['B2','B1','A1','A1'],sort_virtual=['A1','B1'])
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1,permutation=perm)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/h2o/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/h2o_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/h2o_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:37:25 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 3
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry C2v subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 O      0.000000000000   0.000000000000   0.208896721967 AA    0.000000000000   0.000000000000   0.394757592838 Bohr
[INPUT]  2 H      0.000000000000   1.340790387513  -0.836225824317 AA    0.000000000000   2.533726622849  -1.580237786249 Bohr
[INPUT]  3 H      0.000000000000  -1.340790387513  -0.836225824317 AA    0.000000000000  -2.533726622849  -1.580237786249 Bohr

nuclear repulsion = 5.1778291820723
point group symmetry = C2v
num. orbitals of irrep A1 = 4
num. orbitals of irrep B1 = 2
num. orbitals of irrep B2 = 1
number of shells = 5
number of NR pGTOs = 42
number of NR cGTOs = 7
basis = sto-6g
ecp = {}
CPU time:       283.23

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 B1 B2




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpu7avcy9j
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpu7avcy9j
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.339332329992019  LUMO (A1) = 0.167282557811547
Initial guess E= -75.2893250400107  |g|= 3.62811e-08
macro= 0  E= -75.2893250400107  delta_E= 1.42109e-14  |g|= 3.62811e-08  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-75.2893250400107  |g|= 3.62811e-08  total 2 KF 4 JK
converged SCF energy = -75.2893250400107

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 6o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpu7avcy9j
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -75.531148656475  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -75.5311673532478  dE = -1.8696773e-05  S^2 = 0.0000000
               |grad[o]|=0.0049  |grad[c]|= 0.0007326842535747719  |ddm|=0.000143
macro iter 2 (3 JK  1 micro), CASSCF E = -75.5311676809708  dE = -3.2772306e-07  S^2 = 0.0000000
               |grad[o]|=0.000642  |grad[c]|= 6.767893187563792e-05  |ddm|=1.59e-05
macro iter 3 (1 JK  1 micro), CASSCF E = -75.5311676809775  dE = -6.7217343e-12  S^2 = 0.0000000
               |grad[o]|=3.92e-06  |grad[c]|= 2.581963259952526e-06  |ddm|=3.58e-06
1-step CASSCF converged in 3 macro (8 JK 4 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.67208384 1.99504097 1.99903355 1.63286092 0.37290095 0.32807977]
CASSCF energy = -75.5311676809775
CASCI E = -75.5311676809775  E(CI) = -20.3997675005687  S^2 = 0.0000000
original CI Hamiltonian matrix size .......... 225
after projection on GS irrep, matrix size .... 65
after projection on singlet, matrix size ..... 37
Ground state energy (orig)  -75.53114866480037
Ground state energy (pad)  -75.53114866480037
after padding, matrix size ................... 64
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_h2o_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

def geometry(d):
    z0 = 0.1177
    z1 = 0.47116
    y0 = 0.75545
    r0 = np.sqrt(y0**2+(z0+z1)**2)
    r  = d/r0
    return "O 0.0000 0.0000 {0}; H 0.0000 {1} -{2}; H 0.0000 -{1} -{2}".format(z0*r,y0*r,z1*r)

dist_list = [0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/h2o/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = geometry(dist),
                  basis = 'sto-6g',symmetry = 'c2v',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        perm = permute_orbitals(orb_info,nf=1,sort_occupied=['B2','B1','A1','A1'],sort_virtual=['A1','B1'])
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1,permutation=perm)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/h2o/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/h2o_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/h2o_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:38:51 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 3
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry C2v subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 O      0.000000000000   0.000000000000   0.233472806905 AA    0.000000000000   0.000000000000   0.441199662583 Bohr
[INPUT]  2 H      0.000000000000   1.498530433103  -0.934605333061 AA    0.000000000000   2.831812107890  -1.766148114043 Bohr
[INPUT]  3 H      0.000000000000  -1.498530433103  -0.934605333061 AA    0.000000000000  -2.831812107890  -1.766148114043 Bohr

nuclear repulsion = 4.63279453132785
point group symmetry = C2v
num. orbitals of irrep A1 = 4
num. orbitals of irrep B1 = 2
num. orbitals of irrep B2 = 1
number of shells = 5
number of NR pGTOs = 42
number of NR cGTOs = 7
basis = sto-6g
ecp = {}
CPU time:       368.13

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 B1 B2




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpakyhwino
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpakyhwino
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.306021104731703  LUMO (A1) = 0.1162822379247
Initial guess E= -75.1710486899813  |g|= 6.54391e-08
macro= 0  E= -75.1710486899813  delta_E= 2.84217e-14  |g|= 6.54391e-08  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-75.1710486899813  |g|= 6.54391e-08  total 2 KF 4 JK
converged SCF energy = -75.1710486899813

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 6o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpakyhwino
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -75.4934439615099  S^2 = 0.0000001
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -75.4934560361209  dE = -1.2074611e-05  S^2 = 0.0000000
               |grad[o]|=0.00584  |grad[c]|= 0.0007261784195891195  |ddm|=6.3e-05
macro iter 2 (3 JK  1 micro), CASSCF E = -75.4934562448506  dE = -2.0872967e-07  S^2 = 0.0000000
               |grad[o]|=0.000752  |grad[c]|= 5.180865476181695e-05  |ddm|=1.73e-05
macro iter 3 (1 JK  1 micro), CASSCF E = -75.4934562449564  dE = -1.057856e-10  S^2 = 0.0000000
               |grad[o]|=4.96e-06  |grad[c]|= 5.398017404703648e-06  |ddm|=6e-06
1-step CASSCF converged in 3 macro (8 JK 4 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.5028432  1.99650925 1.99947556 1.45152184 0.55202611 0.49762404]
CASSCF energy = -75.4934562449564
CASCI E = -75.4934562449564  E(CI) = -19.9479673772921  S^2 = 0.0000000
original CI Hamiltonian matrix size .......... 225
after projection on GS irrep, matrix size .... 65
after projection on singlet, matrix size ..... 37
Ground state energy (orig)  -75.49344396521025
Ground state energy (pad)  -75.49344396521025
after padding, matrix size ................... 64
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_h2o_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

def geometry(d):
    z0 = 0.1177
    z1 = 0.47116
    y0 = 0.75545
    r0 = np.sqrt(y0**2+(z0+z1)**2)
    r  = d/r0
    return "O 0.0000 0.0000 {0}; H 0.0000 {1} -{2}; H 0.0000 -{1} -{2}".format(z0*r,y0*r,z1*r)

dist_list = [0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/h2o/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = geometry(dist),
                  basis = 'sto-6g',symmetry = 'c2v',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        perm = permute_orbitals(orb_info,nf=1,sort_occupied=['B2','B1','A1','A1'],sort_virtual=['A1','B1'])
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1,permutation=perm)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/h2o/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/h2o_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/h2o_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:40:23 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 3
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry C2v subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 O      0.000000000000   0.000000000000   0.258048891842 AA    0.000000000000   0.000000000000   0.487641732329 Bohr
[INPUT]  2 H      0.000000000000   1.656270478692  -1.032984841804 AA    0.000000000000   3.129897592931  -1.952058441836 Bohr
[INPUT]  3 H      0.000000000000  -1.656270478692  -1.032984841804 AA    0.000000000000  -3.129897592931  -1.952058441836 Bohr

nuclear repulsion = 4.19157600453472
point group symmetry = C2v
num. orbitals of irrep A1 = 4
num. orbitals of irrep B1 = 2
num. orbitals of irrep B2 = 1
number of shells = 5
number of NR pGTOs = 42
number of NR cGTOs = 7
basis = sto-6g
ecp = {}
CPU time:       458.05

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 B1 B2




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp9qm3r5fm
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp9qm3r5fm
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.207053606814404  LUMO (B1) = 0.0430874795484909
Initial guess E= -75.0784298237207  |g|= 1.46515e-10
macro= 0  E= -75.0784298237207  delta_E= 0  |g|= 1.46515e-10  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-75.0784298237207  |g|= 1.46515e-10  total 2 KF 4 JK
converged SCF energy = -75.0784298237207

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 6o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp9qm3r5fm
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -75.4741355207715  S^2 = 0.0000060
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -75.4741415561182  dE = -6.0353467e-06  S^2 = 0.0000039
               |grad[o]|=0.00477  |grad[c]|= 0.0007212679221429552  |ddm|=4.33e-05
macro iter 2 (3 JK  1 micro), CASSCF E = -75.4741416678152  dE = -1.1169696e-07  S^2 = 0.0000027
               |grad[o]|=0.000617  |grad[c]|= 4.946334666380492e-05  |ddm|=3.39e-05
macro iter 3 (1 JK  1 micro), CASSCF E = -75.4741416739846  dE = -6.1693726e-09  S^2 = 0.0000017
               |grad[o]|=1.7e-06  |grad[c]|= 2.3887397150133337e-05  |ddm|=4.04e-05
1-step CASSCF converged in 3 macro (8 JK 4 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.26227376 1.99847218 1.99975679 1.22752079 0.77388227 0.73809421]
CASSCF energy = -75.4741416739846
CASCI E = -75.4741416739846  E(CI) = -19.5934764255203  S^2 = 0.0000017
original CI Hamiltonian matrix size .......... 225
after projection on GS irrep, matrix size .... 65
after projection on singlet, matrix size ..... 37
Ground state energy (orig)  -75.47413555924905
Ground state energy (pad)  -75.47413555924905
after padding, matrix size ................... 64
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_h2o_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

def geometry(d):
    z0 = 0.1177
    z1 = 0.47116
    y0 = 0.75545
    r0 = np.sqrt(y0**2+(z0+z1)**2)
    r  = d/r0
    return "O 0.0000 0.0000 {0}; H 0.0000 {1} -{2}; H 0.0000 -{1} -{2}".format(z0*r,y0*r,z1*r)

dist_list = [0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/h2o/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = geometry(dist),
                  basis = 'sto-6g',symmetry = 'c2v',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        perm = permute_orbitals(orb_info,nf=1,sort_occupied=['B2','B1','A1','A1'],sort_virtual=['A1','B1'])
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1,permutation=perm)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/h2o/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/h2o_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/h2o_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:41:34 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 3
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry C2v subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 O      0.000000000000   0.000000000000   0.282624976779 AA    0.000000000000   0.000000000000   0.534083802075 Bohr
[INPUT]  2 H      0.000000000000   1.814010524282  -1.131364350547 AA    0.000000000000   3.427983077972  -2.137968769630 Bohr
[INPUT]  3 H      0.000000000000  -1.814010524282  -1.131364350547 AA    0.000000000000  -3.427983077972  -2.137968769630 Bohr

nuclear repulsion = 3.82709113457518
point group symmetry = C2v
num. orbitals of irrep A1 = 4
num. orbitals of irrep B1 = 2
num. orbitals of irrep B2 = 1
number of shells = 5
number of NR pGTOs = 42
number of NR cGTOs = 7
basis = sto-6g
ecp = {}
CPU time:       528.47

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 B1 B2




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp7bgghfx5
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp7bgghfx5
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.17283920538394  LUMO (B1) = 0.00692372477486838
Initial guess E= -75.0332073825851  |g|= 5.11967e-09
macro= 0  E= -75.0332073825851  delta_E= 0  |g|= 5.11967e-09  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-75.0332073825851  |g|= 5.11967e-09  total 2 KF 4 JK
converged SCF energy = -75.0332073825851

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 6o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp7bgghfx5
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -75.46548386607  S^2 = 0.0000094
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -75.4654865183604  dE = -2.6522903e-06  S^2 = 0.0000064
               |grad[o]|=0.00326  |grad[c]|= 0.0007180359326377644  |ddm|=2.57e-05
macro iter 2 (2 JK  1 micro), CASSCF E = -75.4654865724709  dE = -5.4110558e-08  S^2 = 0.0000050
               |grad[o]|=0.000443  |grad[c]|= 4.097826490104885e-05  |ddm|=3.41e-05
macro iter 3 (1 JK  1 micro), CASSCF E = -75.4654865755024  dE = -3.0315022e-09  S^2 = 0.0000037
               |grad[o]|=2.91e-06  |grad[c]|= 2.3797981757833273e-05  |ddm|=3.82e-05
1-step CASSCF converged in 3 macro (7 JK 4 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.1082509  1.99940449 1.99989498 1.08906395 0.91144809 0.89193758]
CASSCF energy = -75.4654865755024
CASCI E = -75.4654865755024  E(CI) = -19.3081328803626  S^2 = 0.0000037
original CI Hamiltonian matrix size .......... 225
after projection on GS irrep, matrix size .... 65
after projection on singlet, matrix size ..... 37
Ground state energy (orig)  -75.46548389045111
Ground state energy (pad)  -75.46548389045111
after padding, matrix size ................... 64
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_h2o_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

def geometry(d):
    z0 = 0.1177
    z1 = 0.47116
    y0 = 0.75545
    r0 = np.sqrt(y0**2+(z0+z1)**2)
    r  = d/r0
    return "O 0.0000 0.0000 {0}; H 0.0000 {1} -{2}; H 0.0000 -{1} -{2}".format(z0*r,y0*r,z1*r)

dist_list = [0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/h2o/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = geometry(dist),
                  basis = 'sto-6g',symmetry = 'c2v',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        perm = permute_orbitals(orb_info,nf=1,sort_occupied=['B2','B1','A1','A1'],sort_virtual=['A1','B1'])
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1,permutation=perm)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/h2o/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/h2o_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/h2o_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:42:45 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 3
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry C2v subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 O      0.000000000000   0.000000000000   0.307201061717 AA    0.000000000000   0.000000000000   0.580525871820 Bohr
[INPUT]  2 H      0.000000000000   1.971750569872  -1.229743859290 AA    0.000000000000   3.726068563013  -2.323879097424 Bohr
[INPUT]  3 H      0.000000000000  -1.971750569872  -1.229743859290 AA    0.000000000000  -3.726068563013  -2.323879097424 Bohr

nuclear repulsion = 3.52092384380916
point group symmetry = C2v
num. orbitals of irrep A1 = 4
num. orbitals of irrep B1 = 2
num. orbitals of irrep B2 = 1
number of shells = 5
number of NR pGTOs = 42
number of NR cGTOs = 7
basis = sto-6g
ecp = {}
CPU time:       598.57

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 B1 B2




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpqnqtkmhb
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpqnqtkmhb
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.157830450602224  LUMO (B1) = -0.00915835215012131
Initial guess E= -75.0103866187069  |g|= 2.65796e-08
macro= 0  E= -75.0103866187068  delta_E= 2.84217e-14  |g|= 2.65796e-08  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-75.0103866187068  |g|= 2.65796e-08  total 2 KF 4 JK
converged SCF energy = -75.0103866187068

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 6o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpqnqtkmhb
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -75.4617611744485  S^2 = 0.0000030
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -75.4617623328093  dE = -1.1583608e-06  S^2 = 0.0000025
               |grad[o]|=0.00217  |grad[c]|= 0.0007159687253786185  |ddm|=1.29e-05
macro iter 2 (2 JK  1 micro), CASSCF E = -75.4617623576828  dE = -2.4873486e-08  S^2 = 0.0000024
               |grad[o]|=0.000312  |grad[c]|= 2.97611155779921e-05  |ddm|=8.7e-06
1-step CASSCF converged in 2 macro (6 JK 3 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.04509275 1.99975933 1.99995527 1.03549461 0.96470789 0.95499015]
CASSCF energy = -75.4617623576828
CASCI E = -75.4617623576828  E(CI) = -19.0721105674403  S^2 = 0.0000024
original CI Hamiltonian matrix size .......... 225
after projection on GS irrep, matrix size .... 65
after projection on singlet, matrix size ..... 37
Ground state energy (orig)  -75.46176117868161
Ground state energy (pad)  -75.46176117868161
after padding, matrix size ................... 64
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_h2o_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

def geometry(d):
    z0 = 0.1177
    z1 = 0.47116
    y0 = 0.75545
    r0 = np.sqrt(y0**2+(z0+z1)**2)
    r  = d/r0
    return "O 0.0000 0.0000 {0}; H 0.0000 {1} -{2}; H 0.0000 -{1} -{2}".format(z0*r,y0*r,z1*r)

dist_list = [0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/h2o/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = geometry(dist),
                  basis = 'sto-6g',symmetry = 'c2v',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        perm = permute_orbitals(orb_info,nf=1,sort_occupied=['B2','B1','A1','A1'],sort_virtual=['A1','B1'])
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1,permutation=perm)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/h2o/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/h2o_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/h2o_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:43:58 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 3
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry C2v subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 O      0.000000000000   0.000000000000   0.331777146654 AA    0.000000000000   0.000000000000   0.626967941566 Bohr
[INPUT]  2 H      0.000000000000   2.129490615462  -1.328123368034 AA    0.000000000000   4.024154048054  -2.509789425218 Bohr
[INPUT]  3 H      0.000000000000  -2.129490615462  -1.328123368034 AA    0.000000000000  -4.024154048054  -2.509789425218 Bohr

nuclear repulsion = 3.26011467019367
point group symmetry = C2v
num. orbitals of irrep A1 = 4
num. orbitals of irrep B1 = 2
num. orbitals of irrep B2 = 1
number of shells = 5
number of NR pGTOs = 42
number of NR cGTOs = 7
basis = sto-6g
ecp = {}
CPU time:       670.80

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 B1 B2




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp8yezz59j
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp8yezz59j
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (B1) = -0.152906577508738  LUMO (A1) = -0.0247504856732092
Initial guess E= -74.9953272185317  |g|= 2.32304e-07
macro= 0  E= -74.9953272185317  delta_E= -1.42109e-14  |g|= 2.32304e-07  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-74.9953272185317  |g|= 2.32304e-07  total 2 KF 4 JK
converged SCF energy = -74.9953272185317

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 6o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp8yezz59j
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -75.4601471118985  S^2 = 0.0001855
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -75.4601476351246  dE = -5.2322603e-07  S^2 = 0.0001700
               |grad[o]|=0.00138  |grad[c]|= 0.0007169261366440926  |ddm|=5.34e-05
macro iter 2 (3 JK  1 micro), CASSCF E = -75.4601476531379  dE = -1.801331e-08  S^2 = 0.0001588
               |grad[o]|=0.000207  |grad[c]|= 5.353125805885939e-05  |ddm|=1.82e-05
1-step CASSCF converged in 2 macro (7 JK 3 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.02253349 1.99987272 1.99998104 1.012603   0.9875077  0.97750205]
CASSCF energy = -75.4601476531379
CASCI E = -75.4601476531379  E(CI) = -18.872635681538  S^2 = 0.0001588
original CI Hamiltonian matrix size .......... 225
after projection on GS irrep, matrix size .... 65
after projection on singlet, matrix size ..... 37
Ground state energy (orig)  -75.46014721705383
Ground state energy (pad)  -75.46014721705384
after padding, matrix size ................... 64
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_h2o_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

def geometry(d):
    z0 = 0.1177
    z1 = 0.47116
    y0 = 0.75545
    r0 = np.sqrt(y0**2+(z0+z1)**2)
    r  = d/r0
    return "O 0.0000 0.0000 {0}; H 0.0000 {1} -{2}; H 0.0000 -{1} -{2}".format(z0*r,y0*r,z1*r)

dist_list = [0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/h2o/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = geometry(dist),
                  basis = 'sto-6g',symmetry = 'c2v',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        perm = permute_orbitals(orb_info,nf=1,sort_occupied=['B2','B1','A1','A1'],sort_virtual=['A1','B1'])
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1,permutation=perm)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/h2o/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/h2o_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/h2o_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:45:11 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 3
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry C2v subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 O      0.000000000000   0.000000000000   0.356353231591 AA    0.000000000000   0.000000000000   0.673410011312 Bohr
[INPUT]  2 H      0.000000000000   2.287230661051  -1.426502876777 AA    0.000000000000   4.322239533095  -2.695699753012 Bohr
[INPUT]  3 H      0.000000000000  -2.287230661051  -1.426502876777 AA    0.000000000000  -4.322239533095  -2.695699753012 Bohr

nuclear repulsion = 3.03527917569755
point group symmetry = C2v
num. orbitals of irrep A1 = 4
num. orbitals of irrep B1 = 2
num. orbitals of irrep B2 = 1
number of shells = 5
number of NR pGTOs = 42
number of NR cGTOs = 7
basis = sto-6g
ecp = {}
CPU time:       744.22

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 B1 B2




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpzyd2_cmg
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpzyd2_cmg
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (B1) = -0.14582019323191  LUMO (A1) = -0.0288226492463714
Initial guess E= -74.9883601751406  |g|= 4.99953e-10
macro= 0  E= -74.9883601751407  delta_E= -5.68434e-14  |g|= 4.99953e-10  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-74.9883601751407  |g|= 4.99953e-10  total 2 KF 4 JK
converged SCF energy = -74.9883601751407

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 6o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpzyd2_cmg
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -75.4594400918763  S^2 = 0.0000001
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -75.4594403128134  dE = -2.2093705e-07  S^2 = 0.0000001
               |grad[o]|=0.000896  |grad[c]|= 0.0007155832839116936  |ddm|=8.37e-06
macro iter 2 (2 JK  1 micro), CASSCF E = -75.4594403185045  dE = -5.6911631e-09  S^2 = 0.0000001
               |grad[o]|=0.000141  |grad[c]|= 2.8416909511542736e-05  |ddm|=3.78e-06
1-step CASSCF converged in 2 macro (6 JK 3 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.00953098 1.99995024 1.999992   1.00504548 0.99499727 0.99048403]
CASSCF energy = -75.4594403185045
CASCI E = -75.4594403185045  E(CI) = -18.7013618035631  S^2 = 0.0000001
original CI Hamiltonian matrix size .......... 225
after projection on GS irrep, matrix size .... 65
after projection on singlet, matrix size ..... 37
Ground state energy (orig)  -75.45944009701746
Ground state energy (pad)  -75.45944009701746
after padding, matrix size ................... 64
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_h2o_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

def geometry(d):
    z0 = 0.1177
    z1 = 0.47116
    y0 = 0.75545
    r0 = np.sqrt(y0**2+(z0+z1)**2)
    r  = d/r0
    return "O 0.0000 0.0000 {0}; H 0.0000 {1} -{2}; H 0.0000 -{1} -{2}".format(z0*r,y0*r,z1*r)

dist_list = [0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/h2o/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = geometry(dist),
                  basis = 'sto-6g',symmetry = 'c2v',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        perm = permute_orbitals(orb_info,nf=1,sort_occupied=['B2','B1','A1','A1'],sort_virtual=['A1','B1'])
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1,permutation=perm)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/h2o/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/h2o_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/h2o_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:46:14 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 3
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry C2v subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 O      0.000000000000   0.000000000000   0.380929316529 AA    0.000000000000   0.000000000000   0.719852081057 Bohr
[INPUT]  2 H      0.000000000000   2.444970706641  -1.524882385520 AA    0.000000000000   4.620325018136  -2.881610080806 Bohr
[INPUT]  3 H      0.000000000000  -2.444970706641  -1.524882385520 AA    0.000000000000  -4.620325018136  -2.881610080806 Bohr

nuclear repulsion = 2.83945471274932
point group symmetry = C2v
num. orbitals of irrep A1 = 4
num. orbitals of irrep B1 = 2
num. orbitals of irrep B2 = 1
number of shells = 5
number of NR pGTOs = 42
number of NR cGTOs = 7
basis = sto-6g
ecp = {}
CPU time:       806.57

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 B1 B2




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp1dcndfy1
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp1dcndfy1
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (B1) = -0.140680046459655  LUMO (A1) = -0.0320653222814937
Initial guess E= -74.9836198613485  |g|= 5.55678e-09
macro= 0  E= -74.9836198613485  delta_E= -1.42109e-14  |g|= 5.55678e-09  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-74.9836198613485  |g|= 5.55678e-09  total 2 KF 4 JK
converged SCF energy = -74.9836198613485

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 6o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp1dcndfy1
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -75.4591302202596  S^2 = 0.0005241
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -75.45913031593  dE = -9.5670373e-08  S^2 = 0.0004879
               |grad[o]|=0.000578  |grad[c]|= 0.0007149519595324574  |ddm|=7.05e-06
macro iter 2 (2 JK  1 micro), CASSCF E = -75.4591303196555  dE = -3.7255177e-09  S^2 = 0.0004873
               |grad[o]|=9.39e-05  |grad[c]|= 4.182866395453731e-05  |ddm|=1.23e-05
1-step CASSCF converged in 2 macro (6 JK 3 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.00397727 1.99998037 1.99999664 1.00204688 0.99796979 0.99602905]
CASSCF energy = -75.4591303196555
CASCI E = -75.4591303196555  E(CI) = -18.5524613307231  S^2 = 0.0004873
original CI Hamiltonian matrix size .......... 225
after projection on GS irrep, matrix size .... 65
after projection on singlet, matrix size ..... 37
Ground state energy (orig)  -75.4591302651147
Ground state energy (pad)  -75.4591302651147
after padding, matrix size ................... 64
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_h2o_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

def geometry(d):
    z0 = 0.1177
    z1 = 0.47116
    y0 = 0.75545
    r0 = np.sqrt(y0**2+(z0+z1)**2)
    r  = d/r0
    return "O 0.0000 0.0000 {0}; H 0.0000 {1} -{2}; H 0.0000 -{1} -{2}".format(z0*r,y0*r,z1*r)

dist_list = [0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/h2o/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = geometry(dist),
                  basis = 'sto-6g',symmetry = 'c2v',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        perm = permute_orbitals(orb_info,nf=1,sort_occupied=['B2','B1','A1','A1'],sort_virtual=['A1','B1'])
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1,permutation=perm)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/h2o/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/h2o_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/h2o_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:47:09 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 3
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry C2v subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 O      0.000000000000   0.000000000000   0.405505401466 AA    0.000000000000   0.000000000000   0.766294150803 Bohr
[INPUT]  2 H      0.000000000000   2.602710752231  -1.623261894263 AA    0.000000000000   4.918410503177  -3.067520408600 Bohr
[INPUT]  3 H      0.000000000000  -2.602710752231  -1.623261894263 AA    0.000000000000  -4.918410503177  -3.067520408600 Bohr

nuclear repulsion = 2.66736654834028
point group symmetry = C2v
num. orbitals of irrep A1 = 4
num. orbitals of irrep B1 = 2
num. orbitals of irrep B2 = 1
number of shells = 5
number of NR pGTOs = 42
number of NR cGTOs = 7
basis = sto-6g
ecp = {}
CPU time:       861.18

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 B1 B2




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpqw2mwhbn
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpqw2mwhbn
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (B1) = -0.136643406912728  LUMO (A1) = -0.0348912617041642
Initial guess E= -74.9799842794862  |g|= 2.7529e-08
macro= 0  E= -74.9799842794862  delta_E= 2.84217e-14  |g|= 2.7529e-08  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-74.9799842794862  |g|= 2.7529e-08  total 2 KF 4 JK
converged SCF energy = -74.9799842794862

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 6o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpqw2mwhbn
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -75.4589954639348  S^2 = 0.0013698
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -75.458995491788  dE = -2.7853162e-08  S^2 = 0.0013668
               |grad[o]|=0.000372  |grad[c]|= 0.0001790417908052796  |ddm|=8.97e-06
macro iter 2 (4 JK  2 micro), CASSCF E = -75.4589955054036  dE = -1.3615647e-08  S^2 = 0.0013634
               |grad[o]|=0.000216  |grad[c]|= 0.0002627129392720597  |ddm|=2.62e-06
1-step CASSCF converged in 2 macro (8 JK 4 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.00164427 1.9999922  1.9999986  1.00083428 0.99917225 0.9983584 ]
CASSCF energy = -75.4589955054036
CASCI E = -75.4589955054036  E(CI) = -18.4191381003822  S^2 = 0.0013634
original CI Hamiltonian matrix size .......... 225
after projection on GS irrep, matrix size .... 65
after projection on singlet, matrix size ..... 37
Ground state energy (orig)  -75.45899551346075
Ground state energy (pad)  -75.45899551346075
after padding, matrix size ................... 64
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_h2o_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

def geometry(d):
    z0 = 0.1177
    z1 = 0.47116
    y0 = 0.75545
    r0 = np.sqrt(y0**2+(z0+z1)**2)
    r  = d/r0
    return "O 0.0000 0.0000 {0}; H 0.0000 {1} -{2}; H 0.0000 -{1} -{2}".format(z0*r,y0*r,z1*r)

dist_list = [0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/h2o/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = geometry(dist),
                  basis = 'sto-6g',symmetry = 'c2v',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        perm = permute_orbitals(orb_info,nf=1,sort_occupied=['B2','B1','A1','A1'],sort_virtual=['A1','B1'])
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1,permutation=perm)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/h2o/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/h2o_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/h2o_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:48:04 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 3
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry C2v subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 O      0.000000000000   0.000000000000   0.110592382218 AA    0.000000000000   0.000000000000   0.208989313855 Bohr
[INPUT]  2 H      0.000000000000   0.709830205154  -0.442707789345 AA    0.000000000000   1.341384682685  -0.836596475073 Bohr
[INPUT]  3 H      0.000000000000  -0.709830205154  -0.442707789345 AA    0.000000000000  -1.341384682685  -0.836596475073 Bohr

nuclear repulsion = 9.78034401058101
point group symmetry = C2v
num. orbitals of irrep A1 = 4
num. orbitals of irrep B1 = 2
num. orbitals of irrep B2 = 1
number of shells = 5
number of NR pGTOs = 42
number of NR cGTOs = 7
basis = sto-6g
ecp = {}
CPU time:       916.76

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 B1 B2




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpp9u3mvzk
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpp9u3mvzk
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (B2) = -0.403246261747247  LUMO (A1) = 0.65777200538655
Initial guess E= -75.6620702978116  |g|= 2.3183e-10
macro= 0  E= -75.6620702978116  delta_E= 1.42109e-14  |g|= 2.3183e-10  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-75.6620702978116  |g|= 2.3183e-10  total 2 KF 4 JK
converged SCF energy = -75.6620702978116

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 6o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpp9u3mvzk
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -75.7052258804315  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -75.7052537575338  dE = -2.7877102e-05  S^2 = 0.0000000
               |grad[o]|=0.0019  |grad[c]|= 0.0012151911670723583  |ddm|=0.000131
macro iter 2 (3 JK  1 micro), CASSCF E = -75.7052538008068  dE = -4.3273047e-08  S^2 = 0.0000000
               |grad[o]|=8.74e-05  |grad[c]|= 4.403296201653765e-05  |ddm|=9.55e-06
1-step CASSCF converged in 2 macro (7 JK 3 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99841534 1.97922484 1.99267081 1.98769041 0.02060599 0.02139261]
CASSCF energy = -75.7052538008068
CASCI E = -75.7052538008068  E(CI) = -24.0753137102072  S^2 = 0.0000000
original CI Hamiltonian matrix size .......... 225
after projection on GS irrep, matrix size .... 65
after projection on singlet, matrix size ..... 37
Ground state energy (orig)  -75.70522588044759
Ground state energy (pad)  -75.70522588044759
after padding, matrix size ................... 64
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_h2o_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

def geometry(d):
    z0 = 0.1177
    z1 = 0.47116
    y0 = 0.75545
    r0 = np.sqrt(y0**2+(z0+z1)**2)
    r  = d/r0
    return "O 0.0000 0.0000 {0}; H 0.0000 {1} -{2}; H 0.0000 -{1} -{2}".format(z0*r,y0*r,z1*r)

dist_list = [0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/h2o/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = geometry(dist),
                  basis = 'sto-6g',symmetry = 'c2v',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        perm = permute_orbitals(orb_info,nf=1,sort_occupied=['B2','B1','A1','A1'],sort_virtual=['A1','B1'])
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1,permutation=perm)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/h2o/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/h2o_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/h2o_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:49:18 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 3
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry C2v subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 O      0.000000000000   0.000000000000   0.135168467155 AA    0.000000000000   0.000000000000   0.255431383601 Bohr
[INPUT]  2 H      0.000000000000   0.867570250744  -0.541087298088 AA    0.000000000000   1.639470167726  -1.022506802867 Bohr
[INPUT]  3 H      0.000000000000  -0.867570250744  -0.541087298088 AA    0.000000000000  -1.639470167726  -1.022506802867 Bohr

nuclear repulsion = 8.00209964502083
point group symmetry = C2v
num. orbitals of irrep A1 = 4
num. orbitals of irrep B1 = 2
num. orbitals of irrep B2 = 1
number of shells = 5
number of NR pGTOs = 42
number of NR cGTOs = 7
basis = sto-6g
ecp = {}
CPU time:       988.79

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 B1 B2




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpdk97yyxf
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpdk97yyxf
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (B2) = -0.393117520839696  LUMO (A1) = 0.469291794570369
Initial guess E= -75.6567189616229  |g|= 1.57317e-10
macro= 0  E= -75.656718961623  delta_E= -2.84217e-14  |g|= 1.57317e-10  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-75.656718961623  |g|= 1.57317e-10  total 2 KF 4 JK
converged SCF energy = -75.656718961623

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 6o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpdk97yyxf
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -75.7281287235215  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -75.7281575696102  dE = -2.8846089e-05  S^2 = 0.0000000
               |grad[o]|=0.00239  |grad[c]|= 0.0008701747216560553  |ddm|=0.000147
macro iter 2 (3 JK  1 micro), CASSCF E = -75.7281579320228  dE = -3.6241264e-07  S^2 = 0.0000000
               |grad[o]|=0.000276  |grad[c]|= 9.192137565470445e-05  |ddm|=1.48e-05
macro iter 3 (1 JK  1 micro), CASSCF E = -75.7281579320289  dE = -6.0396133e-12  S^2 = 0.0000000
               |grad[o]|=1.93e-06  |grad[c]|= 3.2749626308109952e-06  |ddm|=2.92e-06
1-step CASSCF converged in 3 macro (8 JK 4 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99818905 1.95279617 1.99106696 1.9604311  0.05018045 0.04733627]
CASSCF energy = -75.7281579320289
CASCI E = -75.7281579320289  E(CI) = -22.7437590638221  S^2 = 0.0000000
original CI Hamiltonian matrix size .......... 225
after projection on GS irrep, matrix size .... 65
after projection on singlet, matrix size ..... 37
Ground state energy (orig)  -75.7281287235618
Ground state energy (pad)  -75.7281287235618
after padding, matrix size ................... 64
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_h2o_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

def geometry(d):
    z0 = 0.1177
    z1 = 0.47116
    y0 = 0.75545
    r0 = np.sqrt(y0**2+(z0+z1)**2)
    r  = d/r0
    return "O 0.0000 0.0000 {0}; H 0.0000 {1} -{2}; H 0.0000 -{1} -{2}".format(z0*r,y0*r,z1*r)

dist_list = [0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/h2o/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = geometry(dist),
                  basis = 'sto-6g',symmetry = 'c2v',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        perm = permute_orbitals(orb_info,nf=1,sort_occupied=['B2','B1','A1','A1'],sort_virtual=['A1','B1'])
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1,permutation=perm)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/h2o/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/h2o_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/h2o_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:50:12 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 3
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry C2v subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 O      0.000000000000   0.000000000000   0.159744552093 AA    0.000000000000   0.000000000000   0.301873453347 Bohr
[INPUT]  2 H      0.000000000000   1.025310296333  -0.639466806831 AA    0.000000000000   1.937555652767  -1.208417130661 Bohr
[INPUT]  3 H      0.000000000000  -1.025310296333  -0.639466806831 AA    0.000000000000  -1.937555652767  -1.208417130661 Bohr

nuclear repulsion = 6.7710073919407
point group symmetry = C2v
num. orbitals of irrep A1 = 4
num. orbitals of irrep B1 = 2
num. orbitals of irrep B2 = 1
number of shells = 5
number of NR pGTOs = 42
number of NR cGTOs = 7
basis = sto-6g
ecp = {}
CPU time:      1043.09

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 B1 B2




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp1zo349xm
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp1zo349xm
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (B2) = -0.397951766204723  LUMO (A1) = 0.33292277271706
Initial guess E= -75.5521478952092  |g|= 6.71691e-08
macro= 0  E= -75.5521478952092  delta_E= -2.84217e-14  |g|= 6.71691e-08  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-75.5521478952092  |g|= 6.71691e-08  total 2 KF 4 JK
converged SCF energy = -75.5521478952092

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 6o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp1zo349xm
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -75.665561063025  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -75.6655892368121  dE = -2.8173787e-05  S^2 = 0.0000000
               |grad[o]|=0.00293  |grad[c]|= 0.0007729501425167214  |ddm|=0.000131
macro iter 2 (3 JK  1 micro), CASSCF E = -75.665589687002  dE = -4.5018992e-07  S^2 = 0.0000000
               |grad[o]|=0.000373  |grad[c]|= 8.862802046823153e-05  |ddm|=1.54e-05
macro iter 3 (1 JK  1 micro), CASSCF E = -75.6655896870084  dE = -6.4375172e-12  S^2 = 0.0000000
               |grad[o]|=2.27e-06  |grad[c]|= 3.1975217028193765e-06  |ddm|=1.68e-06
1-step CASSCF converged in 3 macro (8 JK 4 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99824351 1.90098722 1.9916402  1.89893403 0.11156826 0.09862678]
CASSCF energy = -75.6655896870084
CASCI E = -75.6655896870084  E(CI) = -21.7447501650768  S^2 = 0.0000000
original CI Hamiltonian matrix size .......... 225
after projection on GS irrep, matrix size .... 65
after projection on singlet, matrix size ..... 37
Ground state energy (orig)  -75.66556106346874
Ground state energy (pad)  -75.66556106346874
after padding, matrix size ................... 64
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_h2o_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

def geometry(d):
    z0 = 0.1177
    z1 = 0.47116
    y0 = 0.75545
    r0 = np.sqrt(y0**2+(z0+z1)**2)
    r  = d/r0
    return "O 0.0000 0.0000 {0}; H 0.0000 {1} -{2}; H 0.0000 -{1} -{2}".format(z0*r,y0*r,z1*r)

dist_list = [0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/h2o/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = geometry(dist),
                  basis = 'sto-6g',symmetry = 'c2v',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        perm = permute_orbitals(orb_info,nf=1,sort_occupied=['B2','B1','A1','A1'],sort_virtual=['A1','B1'])
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1,permutation=perm)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/h2o/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/h2o_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/h2o_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:51:06 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 3
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry C2v subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 O      0.000000000000   0.000000000000   0.184320637030 AA    0.000000000000   0.000000000000   0.348315523092 Bohr
[INPUT]  2 H      0.000000000000   1.183050341923  -0.737846315574 AA    0.000000000000   2.235641137808  -1.394327458455 Bohr
[INPUT]  3 H      0.000000000000  -1.183050341923  -0.737846315574 AA    0.000000000000  -2.235641137808  -1.394327458455 Bohr

nuclear repulsion = 5.86820640634861
point group symmetry = C2v
num. orbitals of irrep A1 = 4
num. orbitals of irrep B1 = 2
num. orbitals of irrep B2 = 1
number of shells = 5
number of NR pGTOs = 42
number of NR cGTOs = 7
basis = sto-6g
ecp = {}
CPU time:      1097.35

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 B1 B2




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpxwg20h_a
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpxwg20h_a
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.376164418904664  LUMO (A1) = 0.236272511093415
Initial guess E= -75.4205031995739  |g|= 8.9956e-08
macro= 0  E= -75.4205031995739  delta_E= 0  |g|= 8.9956e-08  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-75.4205031995739  |g|= 8.9956e-08  total 2 KF 4 JK
converged SCF energy = -75.4205031995739

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 6o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpxwg20h_a
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -75.5910185441333  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -75.5910432312252  dE = -2.4687092e-05  S^2 = 0.0000000
               |grad[o]|=0.00373  |grad[c]|= 0.0007433852068104582  |ddm|=0.00012
macro iter 2 (3 JK  1 micro), CASSCF E = -75.5910436486415  dE = -4.1741635e-07  S^2 = 0.0000000
               |grad[o]|=0.000482  |grad[c]|= 7.926509651305309e-05  |ddm|=1.45e-05
macro iter 3 (1 JK  1 micro), CASSCF E = -75.5910436486458  dE = -4.3200998e-12  S^2 = 0.0000000
               |grad[o]|=2.71e-06  |grad[c]|= 2.361219203321278e-06  |ddm|=2.07e-06
1-step CASSCF converged in 3 macro (8 JK 4 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99856059 1.81012825 1.99331707 1.79026602 0.21821394 0.18951413]
CASSCF energy = -75.5910436486458
CASCI E = -75.5910436486458  E(CI) = -20.9840976046429  S^2 = 0.0000000
original CI Hamiltonian matrix size .......... 225
after projection on GS irrep, matrix size .... 65
after projection on singlet, matrix size ..... 37
Ground state energy (orig)  -75.59101854470997
Ground state energy (pad)  -75.59101854470997
after padding, matrix size ................... 64
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_h2o_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

def geometry(d):
    z0 = 0.1177
    z1 = 0.47116
    y0 = 0.75545
    r0 = np.sqrt(y0**2+(z0+z1)**2)
    r  = d/r0
    return "O 0.0000 0.0000 {0}; H 0.0000 {1} -{2}; H 0.0000 -{1} -{2}".format(z0*r,y0*r,z1*r)

dist_list = [0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/h2o/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = geometry(dist),
                  basis = 'sto-6g',symmetry = 'c2v',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        perm = permute_orbitals(orb_info,nf=1,sort_occupied=['B2','B1','A1','A1'],sort_virtual=['A1','B1'])
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1,permutation=perm)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/h2o/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/h2o_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/h2o_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:52:01 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 3
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry C2v subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 O      0.000000000000   0.000000000000   0.208896721967 AA    0.000000000000   0.000000000000   0.394757592838 Bohr
[INPUT]  2 H      0.000000000000   1.340790387513  -0.836225824317 AA    0.000000000000   2.533726622849  -1.580237786249 Bohr
[INPUT]  3 H      0.000000000000  -1.340790387513  -0.836225824317 AA    0.000000000000  -2.533726622849  -1.580237786249 Bohr

nuclear repulsion = 5.1778291820723
point group symmetry = C2v
num. orbitals of irrep A1 = 4
num. orbitals of irrep B1 = 2
num. orbitals of irrep B2 = 1
number of shells = 5
number of NR pGTOs = 42
number of NR cGTOs = 7
basis = sto-6g
ecp = {}
CPU time:      1151.39

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 B1 B2




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpk0p89hm0
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpk0p89hm0
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.339332329992019  LUMO (A1) = 0.167282557811547
Initial guess E= -75.2893250400107  |g|= 3.62811e-08
macro= 0  E= -75.2893250400107  delta_E= 1.42109e-14  |g|= 3.62811e-08  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-75.2893250400107  |g|= 3.62811e-08  total 2 KF 4 JK
converged SCF energy = -75.2893250400107

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 6o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpk0p89hm0
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -75.531148656475  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -75.5311673532478  dE = -1.8696773e-05  S^2 = 0.0000000
               |grad[o]|=0.0049  |grad[c]|= 0.0007326842535747719  |ddm|=0.000143
macro iter 2 (3 JK  1 micro), CASSCF E = -75.5311676809708  dE = -3.2772306e-07  S^2 = 0.0000000
               |grad[o]|=0.000642  |grad[c]|= 6.767893187563792e-05  |ddm|=1.59e-05
macro iter 3 (1 JK  1 micro), CASSCF E = -75.5311676809775  dE = -6.7217343e-12  S^2 = 0.0000000
               |grad[o]|=3.92e-06  |grad[c]|= 2.581963259952526e-06  |ddm|=3.58e-06
1-step CASSCF converged in 3 macro (8 JK 4 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.67208384 1.99504097 1.99903355 1.63286092 0.37290095 0.32807977]
CASSCF energy = -75.5311676809775
CASCI E = -75.5311676809775  E(CI) = -20.3997675005687  S^2 = 0.0000000
original CI Hamiltonian matrix size .......... 225
after projection on GS irrep, matrix size .... 65
after projection on singlet, matrix size ..... 37
Ground state energy (orig)  -75.53114866480037
Ground state energy (pad)  -75.53114866480037
after padding, matrix size ................... 64
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_h2o_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

def geometry(d):
    z0 = 0.1177
    z1 = 0.47116
    y0 = 0.75545
    r0 = np.sqrt(y0**2+(z0+z1)**2)
    r  = d/r0
    return "O 0.0000 0.0000 {0}; H 0.0000 {1} -{2}; H 0.0000 -{1} -{2}".format(z0*r,y0*r,z1*r)

dist_list = [0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/h2o/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = geometry(dist),
                  basis = 'sto-6g',symmetry = 'c2v',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        perm = permute_orbitals(orb_info,nf=1,sort_occupied=['B2','B1','A1','A1'],sort_virtual=['A1','B1'])
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1,permutation=perm)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/h2o/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/h2o_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/h2o_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:52:55 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 3
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry C2v subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 O      0.000000000000   0.000000000000   0.233472806905 AA    0.000000000000   0.000000000000   0.441199662583 Bohr
[INPUT]  2 H      0.000000000000   1.498530433103  -0.934605333061 AA    0.000000000000   2.831812107890  -1.766148114043 Bohr
[INPUT]  3 H      0.000000000000  -1.498530433103  -0.934605333061 AA    0.000000000000  -2.831812107890  -1.766148114043 Bohr

nuclear repulsion = 4.63279453132785
point group symmetry = C2v
num. orbitals of irrep A1 = 4
num. orbitals of irrep B1 = 2
num. orbitals of irrep B2 = 1
number of shells = 5
number of NR pGTOs = 42
number of NR cGTOs = 7
basis = sto-6g
ecp = {}
CPU time:      1205.99

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 B1 B2




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpy9wae0ca
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpy9wae0ca
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.306021104731703  LUMO (A1) = 0.1162822379247
Initial guess E= -75.1710486899813  |g|= 6.54391e-08
macro= 0  E= -75.1710486899813  delta_E= 2.84217e-14  |g|= 6.54391e-08  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-75.1710486899813  |g|= 6.54391e-08  total 2 KF 4 JK
converged SCF energy = -75.1710486899813

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 6o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpy9wae0ca
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -75.4934439615099  S^2 = 0.0000001
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -75.4934560361209  dE = -1.2074611e-05  S^2 = 0.0000000
               |grad[o]|=0.00584  |grad[c]|= 0.0007261784195891195  |ddm|=6.3e-05
macro iter 2 (3 JK  1 micro), CASSCF E = -75.4934562448506  dE = -2.0872967e-07  S^2 = 0.0000000
               |grad[o]|=0.000752  |grad[c]|= 5.180865476181695e-05  |ddm|=1.73e-05
macro iter 3 (1 JK  1 micro), CASSCF E = -75.4934562449564  dE = -1.057856e-10  S^2 = 0.0000000
               |grad[o]|=4.96e-06  |grad[c]|= 5.398017404703648e-06  |ddm|=6e-06
1-step CASSCF converged in 3 macro (8 JK 4 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.5028432  1.99650925 1.99947556 1.45152184 0.55202611 0.49762404]
CASSCF energy = -75.4934562449564
CASCI E = -75.4934562449564  E(CI) = -19.9479673772921  S^2 = 0.0000000
original CI Hamiltonian matrix size .......... 225
after projection on GS irrep, matrix size .... 65
after projection on singlet, matrix size ..... 37
Ground state energy (orig)  -75.49344396521025
Ground state energy (pad)  -75.49344396521025
after padding, matrix size ................... 64
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_h2o_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

def geometry(d):
    z0 = 0.1177
    z1 = 0.47116
    y0 = 0.75545
    r0 = np.sqrt(y0**2+(z0+z1)**2)
    r  = d/r0
    return "O 0.0000 0.0000 {0}; H 0.0000 {1} -{2}; H 0.0000 -{1} -{2}".format(z0*r,y0*r,z1*r)

dist_list = [0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/h2o/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = geometry(dist),
                  basis = 'sto-6g',symmetry = 'c2v',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        perm = permute_orbitals(orb_info,nf=1,sort_occupied=['B2','B1','A1','A1'],sort_virtual=['A1','B1'])
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1,permutation=perm)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/h2o/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/h2o_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/h2o_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:53:50 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 3
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry C2v subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 O      0.000000000000   0.000000000000   0.258048891842 AA    0.000000000000   0.000000000000   0.487641732329 Bohr
[INPUT]  2 H      0.000000000000   1.656270478692  -1.032984841804 AA    0.000000000000   3.129897592931  -1.952058441836 Bohr
[INPUT]  3 H      0.000000000000  -1.656270478692  -1.032984841804 AA    0.000000000000  -3.129897592931  -1.952058441836 Bohr

nuclear repulsion = 4.19157600453472
point group symmetry = C2v
num. orbitals of irrep A1 = 4
num. orbitals of irrep B1 = 2
num. orbitals of irrep B2 = 1
number of shells = 5
number of NR pGTOs = 42
number of NR cGTOs = 7
basis = sto-6g
ecp = {}
CPU time:      1260.74

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 B1 B2




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpegirxuec
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpegirxuec
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.207053606814404  LUMO (B1) = 0.0430874795484909
Initial guess E= -75.0784298237207  |g|= 1.46515e-10
macro= 0  E= -75.0784298237207  delta_E= 0  |g|= 1.46515e-10  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-75.0784298237207  |g|= 1.46515e-10  total 2 KF 4 JK
converged SCF energy = -75.0784298237207

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 6o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpegirxuec
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -75.4741355207715  S^2 = 0.0000060
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -75.4741415561182  dE = -6.0353467e-06  S^2 = 0.0000039
               |grad[o]|=0.00477  |grad[c]|= 0.0007212679221429552  |ddm|=4.33e-05
macro iter 2 (3 JK  1 micro), CASSCF E = -75.4741416678152  dE = -1.1169696e-07  S^2 = 0.0000027
               |grad[o]|=0.000617  |grad[c]|= 4.946334666380492e-05  |ddm|=3.39e-05
macro iter 3 (1 JK  1 micro), CASSCF E = -75.4741416739846  dE = -6.1693726e-09  S^2 = 0.0000017
               |grad[o]|=1.7e-06  |grad[c]|= 2.3887397150133337e-05  |ddm|=4.04e-05
1-step CASSCF converged in 3 macro (8 JK 4 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.26227376 1.99847218 1.99975679 1.22752079 0.77388227 0.73809421]
CASSCF energy = -75.4741416739846
CASCI E = -75.4741416739846  E(CI) = -19.5934764255203  S^2 = 0.0000017
original CI Hamiltonian matrix size .......... 225
after projection on GS irrep, matrix size .... 65
after projection on singlet, matrix size ..... 37
Ground state energy (orig)  -75.47413555924905
Ground state energy (pad)  -75.47413555924905
after padding, matrix size ................... 64
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_h2o_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

def geometry(d):
    z0 = 0.1177
    z1 = 0.47116
    y0 = 0.75545
    r0 = np.sqrt(y0**2+(z0+z1)**2)
    r  = d/r0
    return "O 0.0000 0.0000 {0}; H 0.0000 {1} -{2}; H 0.0000 -{1} -{2}".format(z0*r,y0*r,z1*r)

dist_list = [0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/h2o/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = geometry(dist),
                  basis = 'sto-6g',symmetry = 'c2v',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        perm = permute_orbitals(orb_info,nf=1,sort_occupied=['B2','B1','A1','A1'],sort_virtual=['A1','B1'])
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1,permutation=perm)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/h2o/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/h2o_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/h2o_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:54:49 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 3
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry C2v subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 O      0.000000000000   0.000000000000   0.282624976779 AA    0.000000000000   0.000000000000   0.534083802075 Bohr
[INPUT]  2 H      0.000000000000   1.814010524282  -1.131364350547 AA    0.000000000000   3.427983077972  -2.137968769630 Bohr
[INPUT]  3 H      0.000000000000  -1.814010524282  -1.131364350547 AA    0.000000000000  -3.427983077972  -2.137968769630 Bohr

nuclear repulsion = 3.82709113457518
point group symmetry = C2v
num. orbitals of irrep A1 = 4
num. orbitals of irrep B1 = 2
num. orbitals of irrep B2 = 1
number of shells = 5
number of NR pGTOs = 42
number of NR cGTOs = 7
basis = sto-6g
ecp = {}
CPU time:      1319.41

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 B1 B2




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpoxjv55e5
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpoxjv55e5
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.17283920538394  LUMO (B1) = 0.00692372477486838
Initial guess E= -75.0332073825851  |g|= 5.11967e-09
macro= 0  E= -75.0332073825851  delta_E= 0  |g|= 5.11967e-09  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-75.0332073825851  |g|= 5.11967e-09  total 2 KF 4 JK
converged SCF energy = -75.0332073825851

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 6o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpoxjv55e5
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -75.46548386607  S^2 = 0.0000094
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -75.4654865183604  dE = -2.6522903e-06  S^2 = 0.0000064
               |grad[o]|=0.00326  |grad[c]|= 0.0007180359326377644  |ddm|=2.57e-05
macro iter 2 (2 JK  1 micro), CASSCF E = -75.4654865724709  dE = -5.4110558e-08  S^2 = 0.0000050
               |grad[o]|=0.000443  |grad[c]|= 4.097826490104885e-05  |ddm|=3.41e-05
macro iter 3 (1 JK  1 micro), CASSCF E = -75.4654865755024  dE = -3.0315022e-09  S^2 = 0.0000037
               |grad[o]|=2.91e-06  |grad[c]|= 2.3797981757833273e-05  |ddm|=3.82e-05
1-step CASSCF converged in 3 macro (7 JK 4 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.1082509  1.99940449 1.99989498 1.08906395 0.91144809 0.89193758]
CASSCF energy = -75.4654865755024
CASCI E = -75.4654865755024  E(CI) = -19.3081328803626  S^2 = 0.0000037
original CI Hamiltonian matrix size .......... 225
after projection on GS irrep, matrix size .... 65
after projection on singlet, matrix size ..... 37
Ground state energy (orig)  -75.46548389045111
Ground state energy (pad)  -75.46548389045111
after padding, matrix size ................... 64
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_h2o_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

def geometry(d):
    z0 = 0.1177
    z1 = 0.47116
    y0 = 0.75545
    r0 = np.sqrt(y0**2+(z0+z1)**2)
    r  = d/r0
    return "O 0.0000 0.0000 {0}; H 0.0000 {1} -{2}; H 0.0000 -{1} -{2}".format(z0*r,y0*r,z1*r)

dist_list = [0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/h2o/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = geometry(dist),
                  basis = 'sto-6g',symmetry = 'c2v',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        perm = permute_orbitals(orb_info,nf=1,sort_occupied=['B2','B1','A1','A1'],sort_virtual=['A1','B1'])
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1,permutation=perm)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/h2o/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/h2o_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/h2o_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:55:52 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 3
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry C2v subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 O      0.000000000000   0.000000000000   0.307201061717 AA    0.000000000000   0.000000000000   0.580525871820 Bohr
[INPUT]  2 H      0.000000000000   1.971750569872  -1.229743859290 AA    0.000000000000   3.726068563013  -2.323879097424 Bohr
[INPUT]  3 H      0.000000000000  -1.971750569872  -1.229743859290 AA    0.000000000000  -3.726068563013  -2.323879097424 Bohr

nuclear repulsion = 3.52092384380916
point group symmetry = C2v
num. orbitals of irrep A1 = 4
num. orbitals of irrep B1 = 2
num. orbitals of irrep B2 = 1
number of shells = 5
number of NR pGTOs = 42
number of NR cGTOs = 7
basis = sto-6g
ecp = {}
CPU time:      1383.08

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 B1 B2




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpi_xc12os
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpi_xc12os
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.157830450602224  LUMO (B1) = -0.00915835215012131
Initial guess E= -75.0103866187069  |g|= 2.65796e-08
macro= 0  E= -75.0103866187068  delta_E= 2.84217e-14  |g|= 2.65796e-08  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-75.0103866187068  |g|= 2.65796e-08  total 2 KF 4 JK
converged SCF energy = -75.0103866187068

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 6o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpi_xc12os
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -75.4617611744485  S^2 = 0.0000030
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -75.4617623328093  dE = -1.1583608e-06  S^2 = 0.0000025
               |grad[o]|=0.00217  |grad[c]|= 0.0007159687253786185  |ddm|=1.29e-05
macro iter 2 (2 JK  1 micro), CASSCF E = -75.4617623576828  dE = -2.4873486e-08  S^2 = 0.0000024
               |grad[o]|=0.000312  |grad[c]|= 2.97611155779921e-05  |ddm|=8.7e-06
1-step CASSCF converged in 2 macro (6 JK 3 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.04509275 1.99975933 1.99995527 1.03549461 0.96470789 0.95499015]
CASSCF energy = -75.4617623576828
CASCI E = -75.4617623576828  E(CI) = -19.0721105674403  S^2 = 0.0000024
original CI Hamiltonian matrix size .......... 225
after projection on GS irrep, matrix size .... 65
after projection on singlet, matrix size ..... 37
Ground state energy (orig)  -75.46176117868161
Ground state energy (pad)  -75.46176117868161
after padding, matrix size ................... 64
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_h2o_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

def geometry(d):
    z0 = 0.1177
    z1 = 0.47116
    y0 = 0.75545
    r0 = np.sqrt(y0**2+(z0+z1)**2)
    r  = d/r0
    return "O 0.0000 0.0000 {0}; H 0.0000 {1} -{2}; H 0.0000 -{1} -{2}".format(z0*r,y0*r,z1*r)

dist_list = [0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/h2o/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = geometry(dist),
                  basis = 'sto-6g',symmetry = 'c2v',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        perm = permute_orbitals(orb_info,nf=1,sort_occupied=['B2','B1','A1','A1'],sort_virtual=['A1','B1'])
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1,permutation=perm)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/h2o/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/h2o_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/h2o_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:56:44 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 3
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry C2v subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 O      0.000000000000   0.000000000000   0.331777146654 AA    0.000000000000   0.000000000000   0.626967941566 Bohr
[INPUT]  2 H      0.000000000000   2.129490615462  -1.328123368034 AA    0.000000000000   4.024154048054  -2.509789425218 Bohr
[INPUT]  3 H      0.000000000000  -2.129490615462  -1.328123368034 AA    0.000000000000  -4.024154048054  -2.509789425218 Bohr

nuclear repulsion = 3.26011467019367
point group symmetry = C2v
num. orbitals of irrep A1 = 4
num. orbitals of irrep B1 = 2
num. orbitals of irrep B2 = 1
number of shells = 5
number of NR pGTOs = 42
number of NR cGTOs = 7
basis = sto-6g
ecp = {}
CPU time:      1434.65

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 B1 B2




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp0xlhgqyn
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp0xlhgqyn
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (B1) = -0.152906577508738  LUMO (A1) = -0.0247504856732092
Initial guess E= -74.9953272185317  |g|= 2.32304e-07
macro= 0  E= -74.9953272185317  delta_E= -1.42109e-14  |g|= 2.32304e-07  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-74.9953272185317  |g|= 2.32304e-07  total 2 KF 4 JK
converged SCF energy = -74.9953272185317

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 6o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp0xlhgqyn
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -75.4601471118985  S^2 = 0.0001855
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -75.4601476351246  dE = -5.2322603e-07  S^2 = 0.0001700
               |grad[o]|=0.00138  |grad[c]|= 0.0007169261366440926  |ddm|=5.34e-05
macro iter 2 (3 JK  1 micro), CASSCF E = -75.4601476531379  dE = -1.801331e-08  S^2 = 0.0001588
               |grad[o]|=0.000207  |grad[c]|= 5.353125805885939e-05  |ddm|=1.82e-05
1-step CASSCF converged in 2 macro (7 JK 3 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.02253349 1.99987272 1.99998104 1.012603   0.9875077  0.97750205]
CASSCF energy = -75.4601476531379
CASCI E = -75.4601476531379  E(CI) = -18.872635681538  S^2 = 0.0001588
original CI Hamiltonian matrix size .......... 225
after projection on GS irrep, matrix size .... 65
after projection on singlet, matrix size ..... 37
Ground state energy (orig)  -75.46014721705383
Ground state energy (pad)  -75.46014721705384
after padding, matrix size ................... 64
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_h2o_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

def geometry(d):
    z0 = 0.1177
    z1 = 0.47116
    y0 = 0.75545
    r0 = np.sqrt(y0**2+(z0+z1)**2)
    r  = d/r0
    return "O 0.0000 0.0000 {0}; H 0.0000 {1} -{2}; H 0.0000 -{1} -{2}".format(z0*r,y0*r,z1*r)

dist_list = [0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/h2o/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = geometry(dist),
                  basis = 'sto-6g',symmetry = 'c2v',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        perm = permute_orbitals(orb_info,nf=1,sort_occupied=['B2','B1','A1','A1'],sort_virtual=['A1','B1'])
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1,permutation=perm)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/h2o/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/h2o_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/h2o_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:57:38 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 3
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry C2v subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 O      0.000000000000   0.000000000000   0.356353231591 AA    0.000000000000   0.000000000000   0.673410011312 Bohr
[INPUT]  2 H      0.000000000000   2.287230661051  -1.426502876777 AA    0.000000000000   4.322239533095  -2.695699753012 Bohr
[INPUT]  3 H      0.000000000000  -2.287230661051  -1.426502876777 AA    0.000000000000  -4.322239533095  -2.695699753012 Bohr

nuclear repulsion = 3.03527917569755
point group symmetry = C2v
num. orbitals of irrep A1 = 4
num. orbitals of irrep B1 = 2
num. orbitals of irrep B2 = 1
number of shells = 5
number of NR pGTOs = 42
number of NR cGTOs = 7
basis = sto-6g
ecp = {}
CPU time:      1488.96

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 B1 B2




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpk8asw8jx
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpk8asw8jx
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (B1) = -0.14582019323191  LUMO (A1) = -0.0288226492463714
Initial guess E= -74.9883601751406  |g|= 4.99953e-10
macro= 0  E= -74.9883601751407  delta_E= -5.68434e-14  |g|= 4.99953e-10  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-74.9883601751407  |g|= 4.99953e-10  total 2 KF 4 JK
converged SCF energy = -74.9883601751407

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 6o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpk8asw8jx
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -75.4594400918763  S^2 = 0.0000001
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -75.4594403128134  dE = -2.2093705e-07  S^2 = 0.0000001
               |grad[o]|=0.000896  |grad[c]|= 0.0007155832839116936  |ddm|=8.37e-06
macro iter 2 (2 JK  1 micro), CASSCF E = -75.4594403185045  dE = -5.6911631e-09  S^2 = 0.0000001
               |grad[o]|=0.000141  |grad[c]|= 2.8416909511542736e-05  |ddm|=3.78e-06
1-step CASSCF converged in 2 macro (6 JK 3 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.00953098 1.99995024 1.999992   1.00504548 0.99499727 0.99048403]
CASSCF energy = -75.4594403185045
CASCI E = -75.4594403185045  E(CI) = -18.7013618035631  S^2 = 0.0000001
original CI Hamiltonian matrix size .......... 225
after projection on GS irrep, matrix size .... 65
after projection on singlet, matrix size ..... 37
Ground state energy (orig)  -75.45944009701746
Ground state energy (pad)  -75.45944009701746
after padding, matrix size ................... 64
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_h2o_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

def geometry(d):
    z0 = 0.1177
    z1 = 0.47116
    y0 = 0.75545
    r0 = np.sqrt(y0**2+(z0+z1)**2)
    r  = d/r0
    return "O 0.0000 0.0000 {0}; H 0.0000 {1} -{2}; H 0.0000 -{1} -{2}".format(z0*r,y0*r,z1*r)

dist_list = [0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/h2o/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = geometry(dist),
                  basis = 'sto-6g',symmetry = 'c2v',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        perm = permute_orbitals(orb_info,nf=1,sort_occupied=['B2','B1','A1','A1'],sort_virtual=['A1','B1'])
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1,permutation=perm)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/h2o/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/h2o_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/h2o_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:58:32 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 3
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry C2v subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 O      0.000000000000   0.000000000000   0.380929316529 AA    0.000000000000   0.000000000000   0.719852081057 Bohr
[INPUT]  2 H      0.000000000000   2.444970706641  -1.524882385520 AA    0.000000000000   4.620325018136  -2.881610080806 Bohr
[INPUT]  3 H      0.000000000000  -2.444970706641  -1.524882385520 AA    0.000000000000  -4.620325018136  -2.881610080806 Bohr

nuclear repulsion = 2.83945471274932
point group symmetry = C2v
num. orbitals of irrep A1 = 4
num. orbitals of irrep B1 = 2
num. orbitals of irrep B2 = 1
number of shells = 5
number of NR pGTOs = 42
number of NR cGTOs = 7
basis = sto-6g
ecp = {}
CPU time:      1542.98

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 B1 B2




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpau51snvn
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpau51snvn
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (B1) = -0.140680046459655  LUMO (A1) = -0.0320653222814937
Initial guess E= -74.9836198613485  |g|= 5.55678e-09
macro= 0  E= -74.9836198613485  delta_E= -1.42109e-14  |g|= 5.55678e-09  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-74.9836198613485  |g|= 5.55678e-09  total 2 KF 4 JK
converged SCF energy = -74.9836198613485

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 6o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpau51snvn
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -75.4591302202596  S^2 = 0.0005241
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -75.45913031593  dE = -9.5670373e-08  S^2 = 0.0004879
               |grad[o]|=0.000578  |grad[c]|= 0.0007149519595324574  |ddm|=7.05e-06
macro iter 2 (2 JK  1 micro), CASSCF E = -75.4591303196555  dE = -3.7255177e-09  S^2 = 0.0004873
               |grad[o]|=9.39e-05  |grad[c]|= 4.182866395453731e-05  |ddm|=1.23e-05
1-step CASSCF converged in 2 macro (6 JK 3 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.00397727 1.99998037 1.99999664 1.00204688 0.99796979 0.99602905]
CASSCF energy = -75.4591303196555
CASCI E = -75.4591303196555  E(CI) = -18.5524613307231  S^2 = 0.0004873
original CI Hamiltonian matrix size .......... 225
after projection on GS irrep, matrix size .... 65
after projection on singlet, matrix size ..... 37
Ground state energy (orig)  -75.4591302651147
Ground state energy (pad)  -75.4591302651147
after padding, matrix size ................... 64
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_h2o_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

def geometry(d):
    z0 = 0.1177
    z1 = 0.47116
    y0 = 0.75545
    r0 = np.sqrt(y0**2+(z0+z1)**2)
    r  = d/r0
    return "O 0.0000 0.0000 {0}; H 0.0000 {1} -{2}; H 0.0000 -{1} -{2}".format(z0*r,y0*r,z1*r)

dist_list = [0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/h2o/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = geometry(dist),
                  basis = 'sto-6g',symmetry = 'c2v',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        perm = permute_orbitals(orb_info,nf=1,sort_occupied=['B2','B1','A1','A1'],sort_virtual=['A1','B1'])
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1,permutation=perm)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/h2o/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/h2o_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/h2o_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:59:26 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 3
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry C2v subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 O      0.000000000000   0.000000000000   0.405505401466 AA    0.000000000000   0.000000000000   0.766294150803 Bohr
[INPUT]  2 H      0.000000000000   2.602710752231  -1.623261894263 AA    0.000000000000   4.918410503177  -3.067520408600 Bohr
[INPUT]  3 H      0.000000000000  -2.602710752231  -1.623261894263 AA    0.000000000000  -4.918410503177  -3.067520408600 Bohr

nuclear repulsion = 2.66736654834028
point group symmetry = C2v
num. orbitals of irrep A1 = 4
num. orbitals of irrep B1 = 2
num. orbitals of irrep B2 = 1
number of shells = 5
number of NR pGTOs = 42
number of NR cGTOs = 7
basis = sto-6g
ecp = {}
CPU time:      1596.38

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 B1 B2




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpszkswsi9
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpszkswsi9
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (B1) = -0.136643406912728  LUMO (A1) = -0.0348912617041642
Initial guess E= -74.9799842794862  |g|= 2.7529e-08
macro= 0  E= -74.9799842794862  delta_E= 2.84217e-14  |g|= 2.7529e-08  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-74.9799842794862  |g|= 2.7529e-08  total 2 KF 4 JK
converged SCF energy = -74.9799842794862

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 6o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpszkswsi9
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -75.4589954639348  S^2 = 0.0013698
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -75.458995491788  dE = -2.7853162e-08  S^2 = 0.0013668
               |grad[o]|=0.000372  |grad[c]|= 0.0001790417908052796  |ddm|=8.97e-06
macro iter 2 (4 JK  2 micro), CASSCF E = -75.4589955054036  dE = -1.3615647e-08  S^2 = 0.0013634
               |grad[o]|=0.000216  |grad[c]|= 0.0002627129392720597  |ddm|=2.62e-06
1-step CASSCF converged in 2 macro (8 JK 4 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.00164427 1.9999922  1.9999986  1.00083428 0.99917225 0.9983584 ]
CASSCF energy = -75.4589955054036
CASCI E = -75.4589955054036  E(CI) = -18.4191381003822  S^2 = 0.0013634
original CI Hamiltonian matrix size .......... 225
after projection on GS irrep, matrix size .... 65
after projection on singlet, matrix size ..... 37
Ground state energy (orig)  -75.45899551346075
Ground state energy (pad)  -75.45899551346075
after padding, matrix size ................... 64
RUNNING VAP_VQE
istry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = [['F',(0.0000,0.0000,0.0000)],['H',(0.0000,0.0000, dist)]],
                  basis = 'sto-6g',symmetry = 'coov',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/hf/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/hf_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/hf_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:33:00 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   1.700000000000 AA    0.000000000000   0.000000000000   3.212534411761 Bohr

nuclear repulsion = 2.80152641075294
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:        16.33

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpgzv54s41
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpgzv54s41
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.366580870358538  LUMO (A1) = 0.150293177157103
Initial guess E= -99.2721536741672  |g|= 5.3505e-11
macro= 0  E= -99.2721536741672  delta_E= 1.42109e-14  |g|= 5.3505e-11  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-99.2721536741672  |g|= 5.3505e-11  total 2 KF 4 JK
converged SCF energy = -99.2721536741672

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpgzv54s41
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -99.4193986920378  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -99.4194047843789  dE = -6.0923411e-06  S^2 = 0.0000000
               |grad[o]|=0.00317  |grad[c]|= 0.0008149330895020841  |ddm|=4.51e-05
macro iter 2 (2 JK  1 micro), CASSCF E = -99.4194050560302  dE = -2.7165122e-07  S^2 = 0.0000000
               |grad[o]|=0.000651  |grad[c]|= 8.89983380040323e-05  |ddm|=1.69e-05
macro iter 3 (1 JK  1 micro), CASSCF E = -99.4194050560331  dE = -2.9700686e-12  S^2 = 0.0000000
               |grad[o]|=7.72e-06  |grad[c]|= 2.1976804404875995e-06  |ddm|=2.25e-06
1-step CASSCF converged in 3 macro (7 JK 4 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99888784 1.99970267 1.99970267 1.58404843 0.41765839]
CASSCF energy = -99.4194050560331
CASCI E = -99.4194050560331  E(CI) = -26.1721396630326  S^2 = 0.0000000
original CI Hamiltonian matrix size .......... 25
after projection on GS irrep, matrix size .... 11
after projection on singlet, matrix size ..... 8
Ground state energy (orig)  -99.41939869206347
Ground state energy (pad)  -99.41939869206347
after padding, matrix size ................... 8
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_hf_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = [['F',(0.0000,0.0000,0.0000)],['H',(0.0000,0.0000, dist)]],
                  basis = 'sto-6g',symmetry = 'coov',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/hf/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/hf_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/hf_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:33:01 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   1.900000000000 AA    0.000000000000   0.000000000000   3.590479636674 Bohr

nuclear repulsion = 2.50662889383158
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:        16.83

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpbb4cz5d4
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpbb4cz5d4
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.324314779627263  LUMO (A1) = 0.100249398857483
Initial guess E= -99.2109791084948  |g|= 2.83825e-08
macro= 0  E= -99.2109791084948  delta_E= 0  |g|= 2.83825e-08  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-99.2109791084948  |g|= 2.83825e-08  total 2 KF 4 JK
converged SCF energy = -99.2109791084948

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpbb4cz5d4
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -99.4018220434628  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -99.4018256327789  dE = -3.589316e-06  S^2 = 0.0000000
               |grad[o]|=0.00333  |grad[c]|= 0.0008127225449384163  |ddm|=3.68e-05
macro iter 2 (2 JK  1 micro), CASSCF E = -99.4018257747526  dE = -1.4197371e-07  S^2 = 0.0000000
               |grad[o]|=0.000645  |grad[c]|= 6.889395347937303e-05  |ddm|=1.53e-05
macro iter 3 (1 JK  1 micro), CASSCF E = -99.4018257747537  dE = -1.1226575e-12  S^2 = 0.0000000
               |grad[o]|=6.79e-06  |grad[c]|= 1.3499115157567212e-06  |ddm|=1.31e-06
1-step CASSCF converged in 3 macro (7 JK 4 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99926506 1.9998398  1.9998398  1.42815212 0.57290322]
CASSCF energy = -99.4018257747537
CASCI E = -99.4018257747537  E(CI) = -25.9244298827281  S^2 = 0.0000000
original CI Hamiltonian matrix size .......... 25
after projection on GS irrep, matrix size .... 11
after projection on singlet, matrix size ..... 8
Ground state energy (orig)  -99.40182204346284
Ground state energy (pad)  -99.40182204346284
after padding, matrix size ................... 8
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_hf_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = [['F',(0.0000,0.0000,0.0000)],['H',(0.0000,0.0000, dist)]],
                  basis = 'sto-6g',symmetry = 'coov',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/hf/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/hf_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/hf_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:33:01 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   2.100000000000 AA    0.000000000000   0.000000000000   3.968424861587 Bohr

nuclear repulsion = 2.26790233251429
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:        17.33

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpz3u_p8qx
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpz3u_p8qx
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.289967975223778  LUMO (A1) = 0.0640697934656237
Initial guess E= -99.1613582294051  |g|= 9.62664e-11
macro= 0  E= -99.1613582294051  delta_E= 0  |g|= 9.62664e-11  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-99.1613582294051  |g|= 9.62664e-11  total 2 KF 4 JK
converged SCF energy = -99.1613582294051

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpz3u_p8qx
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -99.392517558481  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -99.3925195051241  dE = -1.9466431e-06  S^2 = 0.0000000
               |grad[o]|=0.00313  |grad[c]|= 0.0008113127011126776  |ddm|=2.78e-05
macro iter 2 (2 JK  1 micro), CASSCF E = -99.3925195766305  dE = -7.1506392e-08  S^2 = 0.0000000
               |grad[o]|=0.000587  |grad[c]|= 5.604815484444966e-05  |ddm|=1.33e-05
macro iter 3 (1 JK  1 micro), CASSCF E = -99.3925195766305  dE = 0  S^2 = 0.0000000
               |grad[o]|=5.71e-06  |grad[c]|= 8.370707269096565e-07  |ddm|=    0
1-step CASSCF converged in 3 macro (7 JK 4 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99953114 1.99992325 1.99992325 1.29710178 0.70352057]
CASSCF energy = -99.3925195766305
CASCI E = -99.3925195766305  E(CI) = -25.729000019705  S^2 = 0.0000000
original CI Hamiltonian matrix size .......... 25
after projection on GS irrep, matrix size .... 11
after projection on singlet, matrix size ..... 8
Ground state energy (orig)  -99.39251755848102
Ground state energy (pad)  -99.39251755848102
after padding, matrix size ................... 8
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_hf_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = [['F',(0.0000,0.0000,0.0000)],['H',(0.0000,0.0000, dist)]],
                  basis = 'sto-6g',symmetry = 'coov',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/hf/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/hf_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/hf_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:33:02 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   2.300000000000 AA    0.000000000000   0.000000000000   4.346370086500 Bohr

nuclear repulsion = 2.07069343403478
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:        17.83

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpw18inv7o
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpw18inv7o
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.262744638798851  LUMO (A1) = 0.0376935153077713
Initial guess E= -99.1226823589012  |g|= 2.79429e-07
macro= 0  E= -99.1226823589012  delta_E= -2.84217e-14  |g|= 2.79429e-07  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-99.1226823589012  |g|= 2.79429e-07  total 2 KF 4 JK
converged SCF energy = -99.1226823589012

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpw18inv7o
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -99.3880016917654  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -99.3880027029934  dE = -1.0112281e-06  S^2 = 0.0000000
               |grad[o]|=0.00273  |grad[c]|= 0.0008104819800313257  |ddm|=1.98e-05
macro iter 2 (3 JK  1 micro), CASSCF E = -99.3880027384813  dE = -3.548783e-08  S^2 = 0.0000000
               |grad[o]|=0.0005  |grad[c]|= 4.676060771188138e-05  |ddm|=1.04e-05
macro iter 3 (1 JK  1 micro), CASSCF E = -99.3880027384813  dE = 0  S^2 = 0.0000000
               |grad[o]|=4.78e-06  |grad[c]|= 5.278760517813304e-07  |ddm|=    0
1-step CASSCF converged in 3 macro (8 JK 4 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.9997037  1.99996569 1.99996569 1.19938099 0.80098393]
CASSCF energy = -99.3880027384813
CASCI E = -99.3880027384813  E(CI) = -25.5708501641761  S^2 = 0.0000000
original CI Hamiltonian matrix size .......... 25
after projection on GS irrep, matrix size .... 11
after projection on singlet, matrix size ..... 8
Ground state energy (orig)  -99.38800169176531
Ground state energy (pad)  -99.38800169176531
after padding, matrix size ................... 8
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_hf_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = [['F',(0.0000,0.0000,0.0000)],['H',(0.0000,0.0000, dist)]],
                  basis = 'sto-6g',symmetry = 'coov',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/hf/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/hf_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/hf_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:33:02 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   2.500000000000 AA    0.000000000000   0.000000000000   4.724315311413 Bohr

nuclear repulsion = 1.905037959312
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:        18.33

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpotnseo80
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpotnseo80
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.24148743122029  LUMO (A1) = 0.0182022590922797
Initial guess E= -99.0932404499966  |g|= 2.18281e-13
macro= 0  E= -99.0932404499966  delta_E= 0  |g|= 2.18293e-13  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-99.0932404499966  |g|= 2.18293e-13  total 2 KF 4 JK
converged SCF energy = -99.0932404499966

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpotnseo80
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -99.3859206843925  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -99.3859212036249  dE = -5.1923239e-07  S^2 = 0.0000000
               |grad[o]|=0.00228  |grad[c]|= 0.0008100213021640194  |ddm|=1.38e-05
macro iter 2 (2 JK  1 micro), CASSCF E = -99.3859212213126  dE = -1.7687753e-08  S^2 = 0.0000000
               |grad[o]|=0.000412  |grad[c]|= 4.329164234037665e-05  |ddm|=8.29e-06
macro iter 3 (1 JK  1 micro), CASSCF E = -99.3859212213126  dE = 0  S^2 = 0.0000000
               |grad[o]|=3.7e-06  |grad[c]|= 3.3717238861058256e-07  |ddm|=    0
1-step CASSCF converged in 3 macro (7 JK 4 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99981022 1.99998526 1.99998526 1.13122191 0.86899735]
CASSCF energy = -99.3859212213126
CASCI E = -99.3859212213126  E(CI) = -25.4397415697712  S^2 = 0.0000000
original CI Hamiltonian matrix size .......... 25
after projection on GS irrep, matrix size .... 11
after projection on singlet, matrix size ..... 8
Ground state energy (orig)  -99.385920684444
Ground state energy (pad)  -99.385920684444
after padding, matrix size ................... 8
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_hf_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = [['F',(0.0000,0.0000,0.0000)],['H',(0.0000,0.0000, dist)]],
                  basis = 'sto-6g',symmetry = 'coov',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/hf/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/hf_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/hf_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:33:03 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   2.700000000000 AA    0.000000000000   0.000000000000   5.102260536326 Bohr

nuclear repulsion = 1.7639240364
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:        18.83

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmppg9rzjyc
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmppg9rzjyc
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.224985116259024  LUMO (A1) = 0.00354474942025124
Initial guess E= -99.0710816036006  |g|= 4.26535e-07
macro= 0  E= -99.0710816036006  delta_E= 2.84217e-14  |g|= 4.26535e-07  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-99.0710816036006  |g|= 4.26535e-07  total 2 KF 4 JK
converged SCF energy = -99.0710816036006

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmppg9rzjyc
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -99.3849927177433  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -99.3849929880873  dE = -2.7034403e-07  S^2 = 0.0000000
               |grad[o]|=0.00186  |grad[c]|= 0.0008097734115262723  |ddm|=8.73e-06
macro iter 2 (2 JK  1 micro), CASSCF E = -99.3849929970954  dE = -9.0080619e-09  S^2 = 0.0000000
               |grad[o]|=0.000333  |grad[c]|= 4.1261662404538e-05  |ddm|=6.45e-06
macro iter 3 (1 JK  1 micro), CASSCF E = -99.3849929970954  dE = 0  S^2 = 0.0000000
               |grad[o]|=2.62e-06  |grad[c]|= 2.1585790179341162e-07  |ddm|=    0
1-step CASSCF converged in 3 macro (7 JK 4 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99987501 1.99999382 1.99999382 1.08533889 0.91479846]
CASSCF energy = -99.3849929970954
CASCI E = -99.3849929970954  E(CI) = -25.3289344041544  S^2 = 0.0000000
original CI Hamiltonian matrix size .......... 25
after projection on GS irrep, matrix size .... 11
after projection on singlet, matrix size ..... 8
Ground state energy (orig)  -99.38499271774695
Ground state energy (pad)  -99.38499271774695
after padding, matrix size ................... 8
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_hf_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = [['F',(0.0000,0.0000,0.0000)],['H',(0.0000,0.0000, dist)]],
                  basis = 'sto-6g',symmetry = 'coov',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/hf/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/hf_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/hf_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:33:03 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   2.900000000000 AA    0.000000000000   0.000000000000   5.480205761239 Bohr

nuclear repulsion = 1.64227410285517
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:        19.31

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp4049udn3
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp4049udn3
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.212147344140101  LUMO (A1) = -0.00770312088091207
Initial guess E= -99.0544327404167  |g|= 1.00378e-13
macro= 0  E= -99.0544327404167  delta_E= 0  |g|= 1.00368e-13  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-99.0544327404167  |g|= 1.00368e-13  total 2 KF 4 JK
converged SCF energy = -99.0544327404167

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp4049udn3
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -99.3845887579858  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -99.3845889040257  dE = -1.4603995e-07  S^2 = 0.0000000
               |grad[o]|=0.00152  |grad[c]|= 0.0008096408056429037  |ddm|=7.77e-06
macro iter 2 (2 JK  1 micro), CASSCF E = -99.3845889088118  dE = -4.7860595e-09  S^2 = 0.0000000
               |grad[o]|=0.000269  |grad[c]|= 4.029347579652764e-05  |ddm|=4.98e-06
1-step CASSCF converged in 2 macro (6 JK 3 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.9999148  1.99999745 1.99999745 1.05506894 0.94502136]
CASSCF energy = -99.3845889088118
CASCI E = -99.3845889088118  E(CI) = -25.2338536124544  S^2 = 0.0000000
original CI Hamiltonian matrix size .......... 25
after projection on GS irrep, matrix size .... 11
after projection on singlet, matrix size ..... 8
Ground state energy (orig)  -99.38458875799078
Ground state energy (pad)  -99.38458875799078
after padding, matrix size ................... 8
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_hf_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = [['F',(0.0000,0.0000,0.0000)],['H',(0.0000,0.0000, dist)]],
                  basis = 'sto-6g',symmetry = 'coov',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/hf/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/hf_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/hf_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:33:04 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   3.100000000000 AA    0.000000000000   0.000000000000   5.858150986152 Bohr

nuclear repulsion = 1.53632093492903
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:        19.81

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpjw4r45hl
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpjw4r45hl
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.202070163395726  LUMO (A1) = -0.0165281195458867
Initial guess E= -99.0418397777126  |g|= 1.6188e-07
macro= 0  E= -99.0418397777126  delta_E= 0  |g|= 1.6188e-07  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-99.0418397777126  |g|= 1.6188e-07  total 2 KF 4 JK
converged SCF energy = -99.0418397777126

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpjw4r45hl
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -99.3844162570877  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -99.3844163404757  dE = -8.338796e-08  S^2 = 0.0000000
               |grad[o]|=0.00125  |grad[c]|= 0.0008095687175108673  |ddm|=8.74e-06
macro iter 2 (3 JK  1 micro), CASSCF E = -99.3844163431757  dE = -2.6999771e-09  S^2 = 0.0000000
               |grad[o]|=0.00022  |grad[c]|= 4.0365074496443164e-05  |ddm|=3.88e-06
1-step CASSCF converged in 2 macro (7 JK 3 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99993984 1.99999896 1.99999896 1.03535639 0.96470585]
CASSCF energy = -99.3844163431757
CASCI E = -99.3844163431757  E(CI) = -25.1512986825357  S^2 = 0.0000000
original CI Hamiltonian matrix size .......... 25
after projection on GS irrep, matrix size .... 11
after projection on singlet, matrix size ..... 8
Ground state energy (orig)  -99.38441625710898
Ground state energy (pad)  -99.38441625710898
after padding, matrix size ................... 8
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_hf_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = [['F',(0.0000,0.0000,0.0000)],['H',(0.0000,0.0000, dist)]],
                  basis = 'sto-6g',symmetry = 'coov',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/hf/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/hf_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/hf_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:33:04 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   3.300000000000 AA    0.000000000000   0.000000000000   6.236096211065 Bohr

nuclear repulsion = 1.44321057523636
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:        20.29

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpoj3fbill
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpoj3fbill
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.194043361807192  LUMO (A1) = -0.0236156021552729
Initial guess E= -99.0321791751506  |g|= 5.09142e-07
macro= 0  E= -99.0321791751506  delta_E= -4.26326e-14  |g|= 5.09142e-07  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-99.0321791751506  |g|= 5.09142e-07  total 2 KF 4 JK
converged SCF energy = -99.0321791751506

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpoj3fbill
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -99.3843436732085  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -99.384343724111  dE = -5.0902514e-08  S^2 = 0.0000000
               |grad[o]|=0.00104  |grad[c]|= 0.000809528347738442  |ddm|=9.28e-06
macro iter 2 (3 JK  1 micro), CASSCF E = -99.3843437257381  dE = -1.6271002e-09  S^2 = 0.0000000
               |grad[o]|=0.000182  |grad[c]|= 4.07097920489111e-05  |ddm|=3.07e-06
1-step CASSCF converged in 2 macro (7 JK 3 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99995611 1.99999958 1.99999958 1.02263032 0.97741443]
CASSCF energy = -99.3843437257381
CASCI E = -99.3843437257381  E(CI) = -25.0788503577368  S^2 = 0.0000000
original CI Hamiltonian matrix size .......... 25
after projection on GS irrep, matrix size .... 11
after projection on singlet, matrix size ..... 8
Ground state energy (orig)  -99.3843436732421
Ground state energy (pad)  -99.3843436732421
after padding, matrix size ................... 8
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_hf_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = [['F',(0.0000,0.0000,0.0000)],['H',(0.0000,0.0000, dist)]],
                  basis = 'sto-6g',symmetry = 'coov',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/hf/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/hf_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/hf_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:33:05 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   3.500000000000 AA    0.000000000000   0.000000000000   6.614041435978 Bohr

nuclear repulsion = 1.36074139950857
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:        20.76

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp_jel4t6v
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp_jel4t6v
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.1875305900461  LUMO (A1) = -0.0294422171042515
Initial guess E= -99.0246183618545  |g|= 1.14122e-06
macro= 0  E= -99.0246183618554  delta_E= -9.09495e-13  |g|= 1.14122e-06  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-99.0246183618554  |g|= 1.14122e-06  total 2 KF 4 JK
converged SCF energy = -99.0246183618554

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp_jel4t6v
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -99.3843134243156  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -99.384313457599  dE = -3.328347e-08  S^2 = 0.0000000
               |grad[o]|=0.000881  |grad[c]|= 0.0008095048455814042  |ddm|=9.37e-06
macro iter 2 (3 JK  1 micro), CASSCF E = -99.3843134586369  dE = -1.0378756e-09  S^2 = 0.0000000
               |grad[o]|=0.000152  |grad[c]|= 4.11517286936402e-05  |ddm|=2.46e-06
1-step CASSCF converged in 2 macro (7 JK 3 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99996703 1.99999983 1.99999983 1.01445694 0.98557638]
CASSCF energy = -99.3843134586369
CASCI E = -99.3843134586369  E(CI) = -25.0147263322809  S^2 = 0.0000000
original CI Hamiltonian matrix size .......... 25
after projection on GS irrep, matrix size .... 11
after projection on singlet, matrix size ..... 8
Ground state energy (orig)  -99.3843134243554
Ground state energy (pad)  -99.3843134243554
after padding, matrix size ................... 8
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_hf_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = [['F',(0.0000,0.0000,0.0000)],['H',(0.0000,0.0000, dist)]],
                  basis = 'sto-6g',symmetry = 'coov',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/hf/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/hf_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/hf_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:33:05 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   3.700000000000 AA    0.000000000000   0.000000000000   6.991986660891 Bohr

nuclear repulsion = 1.28718781034595
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:        21.24

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpgpl14lvf
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpgpl14lvf
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.182138742472354  LUMO (A1) = -0.0343391486455454
Initial guess E= -99.0185601194037  |g|= 1.19475e-11
macro= 0  E= -99.0185601194038  delta_E= -2.84217e-14  |g|= 1.19475e-11  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-99.0185601194038  |g|= 1.19475e-11  total 2 KF 4 JK
converged SCF energy = -99.0185601194038

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpgpl14lvf
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -99.3843008777976  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -99.3843009009819  dE = -2.3184342e-08  S^2 = 0.0000000
               |grad[o]|=0.000757  |grad[c]|= 0.000809490582170683  |ddm|=9.21e-06
macro iter 2 (2 JK  1 micro), CASSCF E = -99.3843009016665  dE = -6.8460793e-10  S^2 = 0.0000000
               |grad[o]|=0.000127  |grad[c]|= 3.4949067604909586e-05  |ddm|=1.99e-06
1-step CASSCF converged in 2 macro (6 JK 3 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99997461 1.99999993 1.99999993 1.00921814 0.99080739]
CASSCF energy = -99.3843009016665
CASCI E = -99.3843009016665  E(CI) = -24.9568606497574  S^2 = 0.0000000
original CI Hamiltonian matrix size .......... 25
after projection on GS irrep, matrix size .... 11
after projection on singlet, matrix size ..... 8
Ground state energy (orig)  -99.38430087783937
Ground state energy (pad)  -99.38430087783937
after padding, matrix size ................... 8
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_hf_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = [['F',(0.0000,0.0000,0.0000)],['H',(0.0000,0.0000, dist)]],
                  basis = 'sto-6g',symmetry = 'coov',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/hf/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/hf_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/hf_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:33:06 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   3.900000000000 AA    0.000000000000   0.000000000000   7.369931885804 Bohr

nuclear repulsion = 1.22117817904615
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:        21.70

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpd9a_amlp
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpd9a_amlp
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.177586145623986  LUMO (A1) = -0.0385366012948476
Initial guess E= -99.0135862783171  |g|= 1.60044e-11
macro= 0  E= -99.0135862783172  delta_E= -2.84217e-14  |g|= 1.60043e-11  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-99.0135862783172  |g|= 1.60043e-11  total 2 KF 4 JK
converged SCF energy = -99.0135862783172

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpd9a_amlp
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -99.3842956828733  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -99.3842956999102  dE = -1.7036953e-08  S^2 = 0.0000000
               |grad[o]|=0.00066  |grad[c]|= 0.0008094815827986739  |ddm|=8.89e-06
macro iter 2 (2 JK  1 micro), CASSCF E = -99.3842957003598  dE = -4.4961723e-10  S^2 = 0.0000000
               |grad[o]|=0.000105  |grad[c]|= 3.05704988814974e-05  |ddm|=1.55e-06
1-step CASSCF converged in 2 macro (6 JK 3 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99998003 1.99999997 1.99999997 1.00585988 0.99416014]
CASSCF energy = -99.3842957003598
CASCI E = -99.3842957003598  E(CI) = -24.9050339607057  S^2 = 0.0000000
original CI Hamiltonian matrix size .......... 25
after projection on GS irrep, matrix size .... 11
after projection on singlet, matrix size ..... 8
Ground state energy (orig)  -99.38429568291431
Ground state energy (pad)  -99.38429568291431
after padding, matrix size ................... 8
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_hf_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = [['F',(0.0000,0.0000,0.0000)],['H',(0.0000,0.0000, dist)]],
                  basis = 'sto-6g',symmetry = 'coov',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/hf/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/hf_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/hf_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:33:06 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   4.100000000000 AA    0.000000000000   0.000000000000   7.747877110717 Bohr

nuclear repulsion = 1.16160851177561
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:        22.17

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp6emmh1hd
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp6emmh1hd
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.173672731751752  LUMO (A1) = -0.0421952265705259
Initial guess E= -99.0094080380603  |g|= 1.74373e-11
macro= 0  E= -99.0094080380603  delta_E= -1.42109e-14  |g|= 1.74373e-11  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-99.0094080380603  |g|= 1.74373e-11  total 2 KF 4 JK
converged SCF energy = -99.0094080380603

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp6emmh1hd
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -99.384293536064  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -99.3842935491384  dE = -1.3074413e-08  S^2 = 0.0000000
               |grad[o]|=0.000583  |grad[c]|= 0.0008094757086514381  |ddm|=8.43e-06
macro iter 2 (2 JK  1 micro), CASSCF E = -99.3842935494118  dE = -2.7338842e-10  S^2 = 0.0000000
               |grad[o]|=8.3e-05  |grad[c]|= 2.3315346036895437e-05  |ddm|=1.12e-06
1-step CASSCF converged in 2 macro (6 JK 3 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99998402 1.99999999 1.99999999 1.0037059  0.9963101 ]
CASSCF energy = -99.3842935494118
CASCI E = -99.3842935494118  E(CI) = -24.8578383902893  S^2 = 0.0000000
original CI Hamiltonian matrix size .......... 25
after projection on GS irrep, matrix size .... 11
after projection on singlet, matrix size ..... 8
Ground state energy (orig)  -99.3842935361028
Ground state energy (pad)  -99.3842935361028
after padding, matrix size ................... 8
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_hf_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = [['F',(0.0000,0.0000,0.0000)],['H',(0.0000,0.0000, dist)]],
                  basis = 'sto-6g',symmetry = 'coov',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/hf/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/hf_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/hf_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:33:06 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   4.300000000000 AA    0.000000000000   0.000000000000   8.125822335630 Bohr

nuclear repulsion = 1.10758020890233
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:        22.64

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmplmh0kz4c
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmplmh0kz4c
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.170256252773826  LUMO (A1) = -0.0454285623802469
Initial guess E= -99.0058262661332  |g|= 1.63161e-11
macro= 0  E= -99.0058262661332  delta_E= -1.42109e-14  |g|= 1.6316e-11  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-99.0058262661332  |g|= 1.6316e-11  total 2 KF 4 JK
converged SCF energy = -99.0058262661332

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmplmh0kz4c
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -99.3842926537504  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -99.3842926641387  dE = -1.0388291e-08  S^2 = 0.0000000
               |grad[o]|=0.00052  |grad[c]|= 0.0008094717473018889  |ddm|=7.8e-06
macro iter 2 (2 JK  1 micro), CASSCF E = -99.3842926642659  dE = -1.271161e-10  S^2 = 0.0000000
               |grad[o]|=5.69e-05  |grad[c]|= 1.2697473780674043e-05  |ddm|=6.1e-07
1-step CASSCF converged in 2 macro (6 JK 3 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99998702 2.         2.         1.00232555 0.99768744]
CASSCF energy = -99.3842926642659
CASCI E = -99.3842926642659  E(CI) = -24.8143236623991  S^2 = 0.0000000
original CI Hamiltonian matrix size .......... 25
after projection on GS irrep, matrix size .... 11
after projection on singlet, matrix size ..... 8
Ground state energy (orig)  -99.384292653786
Ground state energy (pad)  -99.384292653786
after padding, matrix size ................... 8
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_hf_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = [['F',(0.0000,0.0000,0.0000)],['H',(0.0000,0.0000, dist)]],
                  basis = 'sto-6g',symmetry = 'coov',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/hf/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/hf_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/hf_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:33:07 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   4.500000000000 AA    0.000000000000   0.000000000000   8.503767560543 Bohr

nuclear repulsion = 1.05835442184
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:        23.10

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpi8v0etpt
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpi8v0etpt
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.167234340444411  LUMO (A1) = -0.0483184486891664
Initial guess E= -99.0027023161739  |g|= 1.34179e-11
macro= 0  E= -99.0027023161739  delta_E= -1.42109e-14  |g|= 1.34179e-11  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-99.0027023161739  |g|= 1.34179e-11  total 2 KF 4 JK
converged SCF energy = -99.0027023161739

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpi8v0etpt
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -99.3842922953184  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (3 JK  1 micro), CASSCF E = -99.3842923037888  dE = -8.4704368e-09  S^2 = 0.0000000
               |grad[o]|=0.000469  |grad[c]|= 0.0008094865379269299  |ddm|=6.93e-06
macro iter 2 (1 JK  1 micro), CASSCF E = -99.3842923037888  dE = -2.8421709e-14  S^2 = 0.0000000
               |grad[o]|=2e-05  |grad[c]|= 4.7066442559533194e-07  |ddm|=    0
1-step CASSCF converged in 2 macro (4 JK 2 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99998932 2.         2.         1.00144421 0.99856648]
CASSCF energy = -99.3842923037888
CASCI E = -99.3842923037888  E(CI) = -24.7722866885594  S^2 = 0.0000000
original CI Hamiltonian matrix size .......... 25
after projection on GS irrep, matrix size .... 11
after projection on singlet, matrix size ..... 8
Ground state energy (orig)  -99.38429229535043
Ground state energy (pad)  -99.38429229535043
after padding, matrix size ................... 8
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_hf_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = [['F',(0.0000,0.0000,0.0000)],['H',(0.0000,0.0000, dist)]],
                  basis = 'sto-6g',symmetry = 'coov',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/hf/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/hf_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/hf_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:33:07 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   0.500000000000 AA    0.000000000000   0.000000000000   0.944863062283 Bohr

nuclear repulsion = 9.52518979656
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:        23.59

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpins2kmuc
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpins2kmuc
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (E1y) = -0.542449098513258  LUMO (A1) = 1.06641683472435
Initial guess E= -98.6431706488635  |g|= 5.92553e-11
macro= 0  E= -98.6431706488635  delta_E= -7.10543e-14  |g|= 5.92553e-11  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-98.6431706488635  |g|= 5.92553e-11  total 2 KF 4 JK
converged SCF energy = -98.6431706488635

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpins2kmuc
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -98.6492586392853  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (3 JK  1 micro), CASSCF E = -98.649259227325  dE = -5.880397e-07  S^2 = 0.0000000
               |grad[o]|=0.000996  |grad[c]|= 0.0005598508699383355  |ddm|=1.43e-05
macro iter 2 (1 JK  1 micro), CASSCF E = -98.6492592273519  dE = -2.6915359e-11  S^2 = 0.0000000
               |grad[o]|=3.43e-06  |grad[c]|= 8.90228249604693e-06  |ddm|=4.72e-06
1-step CASSCF converged in 2 macro (4 JK 2 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99852367 1.9987067  1.99964162 1.99964162 0.00348639]
CASSCF energy = -98.6492592273519
CASCI E = -98.6492592273519  E(CI) = -30.6193134261933  S^2 = 0.0000000
original CI Hamiltonian matrix size .......... 25
after projection on GS irrep, matrix size .... 11
after projection on singlet, matrix size ..... 8
Ground state energy (orig)  -98.64925863928661
Ground state energy (pad)  -98.64925863928661
after padding, matrix size ................... 8
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_hf_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = [['F',(0.0000,0.0000,0.0000)],['H',(0.0000,0.0000, dist)]],
                  basis = 'sto-6g',symmetry = 'coov',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/hf/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/hf_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/hf_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:33:08 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   0.700000000000 AA    0.000000000000   0.000000000000   1.322808287196 Bohr

nuclear repulsion = 6.80370699754286
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:        24.10

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmplzx94_vl
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmplzx94_vl
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (E1y) = -0.491898144886808  LUMO (A1) = 0.870096594297086
Initial guess E= -99.3566943727443  |g|= 2.50204e-11
macro= 0  E= -99.3566943727443  delta_E= 0  |g|= 2.50205e-11  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-99.3566943727443  |g|= 2.50205e-11  total 2 KF 4 JK
converged SCF energy = -99.3566943727443

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmplzx94_vl
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -99.3698359392924  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -99.3698412952461  dE = -5.3559537e-06  S^2 = 0.0000000
               |grad[o]|=0.00133  |grad[c]|= 0.0010950503430339146  |ddm|=8.24e-05
macro iter 2 (3 JK  1 micro), CASSCF E = -99.3698415927433  dE = -2.9749722e-07  S^2 = 0.0000000
               |grad[o]|=0.000312  |grad[c]|= 0.00013897282844079525  |ddm|=1.37e-05
macro iter 3 (1 JK  1 micro), CASSCF E = -99.3698415927551  dE = -1.1795009e-11  S^2 = 0.0000000
               |grad[o]|=7.08e-06  |grad[c]|= 4.926788526260813e-06  |ddm|=4.84e-06
1-step CASSCF converged in 3 macro (8 JK 4 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99743283 1.99313824 1.99953236 1.99953236 0.01036422]
CASSCF energy = -99.3698415927551
CASCI E = -99.3698415927551  E(CI) = -29.2456901425531  S^2 = 0.0000000
original CI Hamiltonian matrix size .......... 25
after projection on GS irrep, matrix size .... 11
after projection on singlet, matrix size ..... 8
Ground state energy (orig)  -99.3698359392973
Ground state energy (pad)  -99.3698359392973
after padding, matrix size ................... 8
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_hf_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = [['F',(0.0000,0.0000,0.0000)],['H',(0.0000,0.0000, dist)]],
                  basis = 'sto-6g',symmetry = 'coov',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/hf/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/hf_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/hf_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:33:09 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   0.900000000000 AA    0.000000000000   0.000000000000   1.700753512109 Bohr

nuclear repulsion = 5.2917721092
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:        24.64

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp_8fft4po
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp_8fft4po
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (E1y) = -0.474217951730683  LUMO (A1) = 0.635290303157671
Initial guess E= -99.4976185399225  |g|= 2.34849e-10
macro= 0  E= -99.4976185399225  delta_E= -4.26326e-14  |g|= 2.34849e-10  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-99.4976185399225  |g|= 2.34849e-10  total 2 KF 4 JK
converged SCF energy = -99.4976185399225

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp_8fft4po
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -99.5222999464251  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -99.5223100259103  dE = -1.0079485e-05  S^2 = 0.0000000
               |grad[o]|=0.00167  |grad[c]|= 0.000904811459949087  |ddm|=9.02e-05
macro iter 2 (3 JK  1 micro), CASSCF E = -99.5223110352229  dE = -1.0093126e-06  S^2 = 0.0000000
               |grad[o]|=0.000509  |grad[c]|= 0.00023203582563628198  |ddm|=2.62e-05
macro iter 3 (1 JK  1 micro), CASSCF E = -99.5223110352252  dE = -2.3590019e-12  S^2 = 0.0000000
               |grad[o]|=7.79e-06  |grad[c]|= 2.1252507155751018e-06  |ddm|=8.45e-07
1-step CASSCF converged in 3 macro (8 JK 4 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99698639 1.97626122 1.99942733 1.99942733 0.02789773]
CASSCF energy = -99.5223110352252
CASCI E = -99.5223110352252  E(CI) = -28.2225882143454  S^2 = 0.0000000
original CI Hamiltonian matrix size .......... 25
after projection on GS irrep, matrix size .... 11
after projection on singlet, matrix size ..... 8
Ground state energy (orig)  -99.52229994642516
Ground state energy (pad)  -99.52229994642516
after padding, matrix size ................... 8
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_hf_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = [['F',(0.0000,0.0000,0.0000)],['H',(0.0000,0.0000, dist)]],
                  basis = 'sto-6g',symmetry = 'coov',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/hf/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/hf_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/hf_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:33:09 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   1.100000000000 AA    0.000000000000   0.000000000000   2.078698737022 Bohr

nuclear repulsion = 4.32963172570909
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:        25.19

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpj0mjw6yl
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpj0mjw6yl
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (E1y) = -0.471164828789002  LUMO (A1) = 0.450722667315901
Initial guess E= -99.4811742748041  |g|= 1.75641e-10
macro= 0  E= -99.4811742748041  delta_E= 0  |g|= 1.75641e-10  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-99.4811742748041  |g|= 1.75641e-10  total 2 KF 4 JK
converged SCF energy = -99.4811742748041

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpj0mjw6yl
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -99.524178552469  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -99.5241907712433  dE = -1.2218774e-05  S^2 = 0.0000000
               |grad[o]|=0.002  |grad[c]|= 0.0008443495095501067  |ddm|=8.77e-05
macro iter 2 (3 JK  1 micro), CASSCF E = -99.5241918378397  dE = -1.0665964e-06  S^2 = 0.0000000
               |grad[o]|=0.000572  |grad[c]|= 0.00020108970908869209  |ddm|=2.47e-05
macro iter 3 (1 JK  1 micro), CASSCF E = -99.5241918378756  dE = -3.5939252e-11  S^2 = 0.0000000
               |grad[o]|=1.22e-05  |grad[c]|= 7.987384267988116e-06  |ddm|=8.5e-06
1-step CASSCF converged in 3 macro (8 JK 4 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99725266 1.93653157 1.99937227 1.99937227 0.06747124]
CASSCF energy = -99.5241918378756
CASCI E = -99.5241918378756  E(CI) = -27.4720961063268  S^2 = 0.0000000
original CI Hamiltonian matrix size .......... 25
after projection on GS irrep, matrix size .... 11
after projection on singlet, matrix size ..... 8
Ground state energy (orig)  -99.52417855250823
Ground state energy (pad)  -99.52417855250823
after padding, matrix size ................... 8
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_hf_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = [['F',(0.0000,0.0000,0.0000)],['H',(0.0000,0.0000, dist)]],
                  basis = 'sto-6g',symmetry = 'coov',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/hf/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/hf_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/hf_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:33:10 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   1.300000000000 AA    0.000000000000   0.000000000000   2.456643961935 Bohr

nuclear repulsion = 3.66353453713846
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:        25.73

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp1clebwx1
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp1clebwx1
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (E1y) = -0.472630543991933  LUMO (A1) = 0.316375293476612
Initial guess E= -99.4175531085697  |g|= 3.10423e-10
macro= 0  E= -99.4175531085697  delta_E= 1.42109e-14  |g|= 3.10423e-10  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-99.4175531085697  |g|= 3.10423e-10  total 2 KF 4 JK
converged SCF energy = -99.4175531085697

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp1clebwx1
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -99.4873310609179  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -99.4873426593609  dE = -1.1598443e-05  S^2 = 0.0000000
               |grad[o]|=0.00232  |grad[c]|= 0.0008251879140132316  |ddm|=7.2e-05
macro iter 2 (2 JK  1 micro), CASSCF E = -99.4873434457746  dE = -7.8641366e-07  S^2 = 0.0000000
               |grad[o]|=0.000586  |grad[c]|= 0.00015620023813076058  |ddm|=2.16e-05
macro iter 3 (1 JK  1 micro), CASSCF E = -99.4873434457918  dE = -1.7237767e-11  S^2 = 0.0000000
               |grad[o]|=1.07e-05  |grad[c]|= 5.552256702158863e-06  |ddm|=5.77e-06
1-step CASSCF converged in 3 macro (7 JK 4 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.9978254  1.85986869 1.99940701 1.99940701 0.1434919 ]
CASSCF energy = -99.4873434457918
CASCI E = -99.4873434457918  E(CI) = -26.9139463073601  S^2 = 0.0000000
original CI Hamiltonian matrix size .......... 25
after projection on GS irrep, matrix size .... 11
after projection on singlet, matrix size ..... 8
Ground state energy (orig)  -99.48733106092097
Ground state energy (pad)  -99.48733106092097
after padding, matrix size ................... 8
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_hf_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = [['F',(0.0000,0.0000,0.0000)],['H',(0.0000,0.0000, dist)]],
                  basis = 'sto-6g',symmetry = 'coov',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/hf/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/hf_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/hf_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:33:10 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   1.500000000000 AA    0.000000000000   0.000000000000   2.834589186848 Bohr

nuclear repulsion = 3.17506326552
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:        26.28

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpy_3p9itn
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpy_3p9itn
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.416857352082889  LUMO (A1) = 0.219769848446538
Initial guess E= -99.3430560539903  |g|= 3.26563e-09
macro= 0  E= -99.3430560539903  delta_E= -1.42109e-14  |g|= 3.26563e-09  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-99.3430560539903  |g|= 3.26563e-09  total 2 KF 4 JK
converged SCF energy = -99.3430560539903

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpy_3p9itn
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -99.4483488824887  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -99.448357995438  dE = -9.1129493e-06  S^2 = 0.0000000
               |grad[o]|=0.00274  |grad[c]|= 0.0008183706265176677  |ddm|=5.65e-05
macro iter 2 (2 JK  1 micro), CASSCF E = -99.4483584825531  dE = -4.8711512e-07  S^2 = 0.0000000
               |grad[o]|=0.000616  |grad[c]|= 0.00011798015456237586  |ddm|=1.88e-05
macro iter 3 (1 JK  1 micro), CASSCF E = -99.4483584825608  dE = -7.6596507e-12  S^2 = 0.0000000
               |grad[o]|=8.68e-06  |grad[c]|= 3.5851155092078285e-06  |ddm|=3.77e-06
1-step CASSCF converged in 3 macro (7 JK 4 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99840144 1.99953554 1.99953554 1.73828215 0.26424534]
CASSCF energy = -99.4483584825608
CASCI E = -99.4483584825608  E(CI) = -26.4929234379962  S^2 = 0.0000000
original CI Hamiltonian matrix size .......... 25
after projection on GS irrep, matrix size .... 11
after projection on singlet, matrix size ..... 8
Ground state energy (orig)  -99.44834888249717
Ground state energy (pad)  -99.44834888249717
after padding, matrix size ................... 8
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_hf_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = [['F',(0.0000,0.0000,0.0000)],['H',(0.0000,0.0000, dist)]],
                  basis = 'sto-6g',symmetry = 'coov',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/hf/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/hf_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/hf_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:33:11 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   1.700000000000 AA    0.000000000000   0.000000000000   3.212534411761 Bohr

nuclear repulsion = 2.80152641075294
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:        26.82

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpotx_schb
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpotx_schb
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.366580870358538  LUMO (A1) = 0.150293177157103
Initial guess E= -99.2721536741672  |g|= 5.3505e-11
macro= 0  E= -99.2721536741672  delta_E= 1.42109e-14  |g|= 5.3505e-11  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-99.2721536741672  |g|= 5.3505e-11  total 2 KF 4 JK
converged SCF energy = -99.2721536741672

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpotx_schb
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -99.4193986920378  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -99.4194047843789  dE = -6.0923411e-06  S^2 = 0.0000000
               |grad[o]|=0.00317  |grad[c]|= 0.0008149330895020841  |ddm|=4.51e-05
macro iter 2 (2 JK  1 micro), CASSCF E = -99.4194050560302  dE = -2.7165122e-07  S^2 = 0.0000000
               |grad[o]|=0.000651  |grad[c]|= 8.89983380040323e-05  |ddm|=1.69e-05
macro iter 3 (1 JK  1 micro), CASSCF E = -99.4194050560331  dE = -2.9700686e-12  S^2 = 0.0000000
               |grad[o]|=7.72e-06  |grad[c]|= 2.1976804404875995e-06  |ddm|=2.25e-06
1-step CASSCF converged in 3 macro (7 JK 4 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99888784 1.99970267 1.99970267 1.58404843 0.41765839]
CASSCF energy = -99.4194050560331
CASCI E = -99.4194050560331  E(CI) = -26.1721396630326  S^2 = 0.0000000
original CI Hamiltonian matrix size .......... 25
after projection on GS irrep, matrix size .... 11
after projection on singlet, matrix size ..... 8
Ground state energy (orig)  -99.41939869206347
Ground state energy (pad)  -99.41939869206347
after padding, matrix size ................... 8
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_hf_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = [['F',(0.0000,0.0000,0.0000)],['H',(0.0000,0.0000, dist)]],
                  basis = 'sto-6g',symmetry = 'coov',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/hf/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/hf_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/hf_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:33:11 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   1.900000000000 AA    0.000000000000   0.000000000000   3.590479636674 Bohr

nuclear repulsion = 2.50662889383158
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:        27.36

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpebcmj42h
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpebcmj42h
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.324314779627263  LUMO (A1) = 0.100249398857483
Initial guess E= -99.2109791084948  |g|= 2.83825e-08
macro= 0  E= -99.2109791084948  delta_E= 0  |g|= 2.83825e-08  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-99.2109791084948  |g|= 2.83825e-08  total 2 KF 4 JK
converged SCF energy = -99.2109791084948

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpebcmj42h
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -99.4018220434628  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -99.4018256327789  dE = -3.589316e-06  S^2 = 0.0000000
               |grad[o]|=0.00333  |grad[c]|= 0.0008127225449384163  |ddm|=3.68e-05
macro iter 2 (2 JK  1 micro), CASSCF E = -99.4018257747526  dE = -1.4197371e-07  S^2 = 0.0000000
               |grad[o]|=0.000645  |grad[c]|= 6.889395347937303e-05  |ddm|=1.53e-05
macro iter 3 (1 JK  1 micro), CASSCF E = -99.4018257747537  dE = -1.1226575e-12  S^2 = 0.0000000
               |grad[o]|=6.79e-06  |grad[c]|= 1.3499115157567212e-06  |ddm|=1.31e-06
1-step CASSCF converged in 3 macro (7 JK 4 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99926506 1.9998398  1.9998398  1.42815212 0.57290322]
CASSCF energy = -99.4018257747537
CASCI E = -99.4018257747537  E(CI) = -25.9244298827281  S^2 = 0.0000000
original CI Hamiltonian matrix size .......... 25
after projection on GS irrep, matrix size .... 11
after projection on singlet, matrix size ..... 8
Ground state energy (orig)  -99.40182204346284
Ground state energy (pad)  -99.40182204346284
after padding, matrix size ................... 8
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_hf_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = [['F',(0.0000,0.0000,0.0000)],['H',(0.0000,0.0000, dist)]],
                  basis = 'sto-6g',symmetry = 'coov',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/hf/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/hf_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/hf_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:33:12 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   2.100000000000 AA    0.000000000000   0.000000000000   3.968424861587 Bohr

nuclear repulsion = 2.26790233251429
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:        27.92

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpd7j95jkj
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpd7j95jkj
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.289967975223778  LUMO (A1) = 0.0640697934656237
Initial guess E= -99.1613582294051  |g|= 9.62664e-11
macro= 0  E= -99.1613582294051  delta_E= 0  |g|= 9.62664e-11  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-99.1613582294051  |g|= 9.62664e-11  total 2 KF 4 JK
converged SCF energy = -99.1613582294051

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpd7j95jkj
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -99.392517558481  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -99.3925195051241  dE = -1.9466431e-06  S^2 = 0.0000000
               |grad[o]|=0.00313  |grad[c]|= 0.0008113127011126776  |ddm|=2.78e-05
macro iter 2 (2 JK  1 micro), CASSCF E = -99.3925195766305  dE = -7.1506392e-08  S^2 = 0.0000000
               |grad[o]|=0.000587  |grad[c]|= 5.604815484444966e-05  |ddm|=1.33e-05
macro iter 3 (1 JK  1 micro), CASSCF E = -99.3925195766305  dE = 0  S^2 = 0.0000000
               |grad[o]|=5.71e-06  |grad[c]|= 8.370707269096565e-07  |ddm|=    0
1-step CASSCF converged in 3 macro (7 JK 4 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99953114 1.99992325 1.99992325 1.29710178 0.70352057]
CASSCF energy = -99.3925195766305
CASCI E = -99.3925195766305  E(CI) = -25.729000019705  S^2 = 0.0000000
original CI Hamiltonian matrix size .......... 25
after projection on GS irrep, matrix size .... 11
after projection on singlet, matrix size ..... 8
Ground state energy (orig)  -99.39251755848102
Ground state energy (pad)  -99.39251755848102
after padding, matrix size ................... 8
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_hf_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = [['F',(0.0000,0.0000,0.0000)],['H',(0.0000,0.0000, dist)]],
                  basis = 'sto-6g',symmetry = 'coov',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/hf/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/hf_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/hf_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:33:12 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   2.300000000000 AA    0.000000000000   0.000000000000   4.346370086500 Bohr

nuclear repulsion = 2.07069343403478
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:        28.58

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpfb_zyml6
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpfb_zyml6
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.262744638798851  LUMO (A1) = 0.0376935153077713
Initial guess E= -99.1226823589012  |g|= 2.79429e-07
macro= 0  E= -99.1226823589012  delta_E= -2.84217e-14  |g|= 2.79429e-07  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-99.1226823589012  |g|= 2.79429e-07  total 2 KF 4 JK
converged SCF energy = -99.1226823589012

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpfb_zyml6
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -99.3880016917654  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -99.3880027029934  dE = -1.0112281e-06  S^2 = 0.0000000
               |grad[o]|=0.00273  |grad[c]|= 0.0008104819800313257  |ddm|=1.98e-05
macro iter 2 (3 JK  1 micro), CASSCF E = -99.3880027384813  dE = -3.548783e-08  S^2 = 0.0000000
               |grad[o]|=0.0005  |grad[c]|= 4.676060771188138e-05  |ddm|=1.04e-05
macro iter 3 (1 JK  1 micro), CASSCF E = -99.3880027384813  dE = 0  S^2 = 0.0000000
               |grad[o]|=4.78e-06  |grad[c]|= 5.278760517813304e-07  |ddm|=    0
1-step CASSCF converged in 3 macro (8 JK 4 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.9997037  1.99996569 1.99996569 1.19938099 0.80098393]
CASSCF energy = -99.3880027384813
CASCI E = -99.3880027384813  E(CI) = -25.5708501641761  S^2 = 0.0000000
original CI Hamiltonian matrix size .......... 25
after projection on GS irrep, matrix size .... 11
after projection on singlet, matrix size ..... 8
Ground state energy (orig)  -99.38800169176531
Ground state energy (pad)  -99.38800169176531
after padding, matrix size ................... 8
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_hf_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = [['F',(0.0000,0.0000,0.0000)],['H',(0.0000,0.0000, dist)]],
                  basis = 'sto-6g',symmetry = 'coov',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/hf/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/hf_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/hf_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:33:13 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   2.500000000000 AA    0.000000000000   0.000000000000   4.724315311413 Bohr

nuclear repulsion = 1.905037959312
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:        29.18

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp14errj63
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp14errj63
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.24148743122029  LUMO (A1) = 0.0182022590922797
Initial guess E= -99.0932404499966  |g|= 2.18281e-13
macro= 0  E= -99.0932404499966  delta_E= 0  |g|= 2.18293e-13  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-99.0932404499966  |g|= 2.18293e-13  total 2 KF 4 JK
converged SCF energy = -99.0932404499966

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp14errj63
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -99.3859206843925  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -99.3859212036249  dE = -5.1923239e-07  S^2 = 0.0000000
               |grad[o]|=0.00228  |grad[c]|= 0.0008100213021640194  |ddm|=1.38e-05
macro iter 2 (2 JK  1 micro), CASSCF E = -99.3859212213126  dE = -1.7687753e-08  S^2 = 0.0000000
               |grad[o]|=0.000412  |grad[c]|= 4.329164234037665e-05  |ddm|=8.29e-06
macro iter 3 (1 JK  1 micro), CASSCF E = -99.3859212213126  dE = 0  S^2 = 0.0000000
               |grad[o]|=3.7e-06  |grad[c]|= 3.3717238861058256e-07  |ddm|=    0
1-step CASSCF converged in 3 macro (7 JK 4 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99981022 1.99998526 1.99998526 1.13122191 0.86899735]
CASSCF energy = -99.3859212213126
CASCI E = -99.3859212213126  E(CI) = -25.4397415697712  S^2 = 0.0000000
original CI Hamiltonian matrix size .......... 25
after projection on GS irrep, matrix size .... 11
after projection on singlet, matrix size ..... 8
Ground state energy (orig)  -99.385920684444
Ground state energy (pad)  -99.385920684444
after padding, matrix size ................... 8
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_hf_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = [['F',(0.0000,0.0000,0.0000)],['H',(0.0000,0.0000, dist)]],
                  basis = 'sto-6g',symmetry = 'coov',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/hf/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/hf_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/hf_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:33:14 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   2.700000000000 AA    0.000000000000   0.000000000000   5.102260536326 Bohr

nuclear repulsion = 1.7639240364
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:        29.77

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpo5c0210s
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpo5c0210s
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.224985116259024  LUMO (A1) = 0.00354474942025124
Initial guess E= -99.0710816036006  |g|= 4.26535e-07
macro= 0  E= -99.0710816036006  delta_E= 2.84217e-14  |g|= 4.26535e-07  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-99.0710816036006  |g|= 4.26535e-07  total 2 KF 4 JK
converged SCF energy = -99.0710816036006

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpo5c0210s
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -99.3849927177433  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -99.3849929880873  dE = -2.7034403e-07  S^2 = 0.0000000
               |grad[o]|=0.00186  |grad[c]|= 0.0008097734115262723  |ddm|=8.73e-06
macro iter 2 (2 JK  1 micro), CASSCF E = -99.3849929970954  dE = -9.0080619e-09  S^2 = 0.0000000
               |grad[o]|=0.000333  |grad[c]|= 4.1261662404538e-05  |ddm|=6.45e-06
macro iter 3 (1 JK  1 micro), CASSCF E = -99.3849929970954  dE = 0  S^2 = 0.0000000
               |grad[o]|=2.62e-06  |grad[c]|= 2.1585790179341162e-07  |ddm|=    0
1-step CASSCF converged in 3 macro (7 JK 4 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99987501 1.99999382 1.99999382 1.08533889 0.91479846]
CASSCF energy = -99.3849929970954
CASCI E = -99.3849929970954  E(CI) = -25.3289344041544  S^2 = 0.0000000
original CI Hamiltonian matrix size .......... 25
after projection on GS irrep, matrix size .... 11
after projection on singlet, matrix size ..... 8
Ground state energy (orig)  -99.38499271774695
Ground state energy (pad)  -99.38499271774695
after padding, matrix size ................... 8
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_hf_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = [['F',(0.0000,0.0000,0.0000)],['H',(0.0000,0.0000, dist)]],
                  basis = 'sto-6g',symmetry = 'coov',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/hf/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/hf_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/hf_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:33:14 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   2.900000000000 AA    0.000000000000   0.000000000000   5.480205761239 Bohr

nuclear repulsion = 1.64227410285517
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:        30.36

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpaplsm8yh
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpaplsm8yh
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.212147344140101  LUMO (A1) = -0.00770312088091207
Initial guess E= -99.0544327404167  |g|= 1.00378e-13
macro= 0  E= -99.0544327404167  delta_E= 0  |g|= 1.00368e-13  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-99.0544327404167  |g|= 1.00368e-13  total 2 KF 4 JK
converged SCF energy = -99.0544327404167

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpaplsm8yh
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -99.3845887579858  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -99.3845889040257  dE = -1.4603995e-07  S^2 = 0.0000000
               |grad[o]|=0.00152  |grad[c]|= 0.0008096408056429037  |ddm|=7.77e-06
macro iter 2 (2 JK  1 micro), CASSCF E = -99.3845889088118  dE = -4.7860595e-09  S^2 = 0.0000000
               |grad[o]|=0.000269  |grad[c]|= 4.029347579652764e-05  |ddm|=4.98e-06
1-step CASSCF converged in 2 macro (6 JK 3 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.9999148  1.99999745 1.99999745 1.05506894 0.94502136]
CASSCF energy = -99.3845889088118
CASCI E = -99.3845889088118  E(CI) = -25.2338536124544  S^2 = 0.0000000
original CI Hamiltonian matrix size .......... 25
after projection on GS irrep, matrix size .... 11
after projection on singlet, matrix size ..... 8
Ground state energy (orig)  -99.38458875799078
Ground state energy (pad)  -99.38458875799078
after padding, matrix size ................... 8
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_hf_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = [['F',(0.0000,0.0000,0.0000)],['H',(0.0000,0.0000, dist)]],
                  basis = 'sto-6g',symmetry = 'coov',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/hf/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/hf_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/hf_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:33:15 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   3.100000000000 AA    0.000000000000   0.000000000000   5.858150986152 Bohr

nuclear repulsion = 1.53632093492903
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:        31.00

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpt4lmhfru
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpt4lmhfru
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.202070163395726  LUMO (A1) = -0.0165281195458867
Initial guess E= -99.0418397777126  |g|= 1.6188e-07
macro= 0  E= -99.0418397777126  delta_E= 0  |g|= 1.6188e-07  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-99.0418397777126  |g|= 1.6188e-07  total 2 KF 4 JK
converged SCF energy = -99.0418397777126

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpt4lmhfru
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -99.3844162570877  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -99.3844163404757  dE = -8.338796e-08  S^2 = 0.0000000
               |grad[o]|=0.00125  |grad[c]|= 0.0008095687175108673  |ddm|=8.74e-06
macro iter 2 (3 JK  1 micro), CASSCF E = -99.3844163431757  dE = -2.6999771e-09  S^2 = 0.0000000
               |grad[o]|=0.00022  |grad[c]|= 4.0365074496443164e-05  |ddm|=3.88e-06
1-step CASSCF converged in 2 macro (7 JK 3 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99993984 1.99999896 1.99999896 1.03535639 0.96470585]
CASSCF energy = -99.3844163431757
CASCI E = -99.3844163431757  E(CI) = -25.1512986825357  S^2 = 0.0000000
original CI Hamiltonian matrix size .......... 25
after projection on GS irrep, matrix size .... 11
after projection on singlet, matrix size ..... 8
Ground state energy (orig)  -99.38441625710898
Ground state energy (pad)  -99.38441625710898
after padding, matrix size ................... 8
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_hf_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = [['F',(0.0000,0.0000,0.0000)],['H',(0.0000,0.0000, dist)]],
                  basis = 'sto-6g',symmetry = 'coov',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/hf/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/hf_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/hf_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:33:16 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   3.300000000000 AA    0.000000000000   0.000000000000   6.236096211065 Bohr

nuclear repulsion = 1.44321057523636
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:        31.58

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmputnqcvq9
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmputnqcvq9
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.194043361807192  LUMO (A1) = -0.0236156021552729
Initial guess E= -99.0321791751506  |g|= 5.09142e-07
macro= 0  E= -99.0321791751506  delta_E= -4.26326e-14  |g|= 5.09142e-07  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-99.0321791751506  |g|= 5.09142e-07  total 2 KF 4 JK
converged SCF energy = -99.0321791751506

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmputnqcvq9
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -99.3843436732085  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -99.384343724111  dE = -5.0902514e-08  S^2 = 0.0000000
               |grad[o]|=0.00104  |grad[c]|= 0.000809528347738442  |ddm|=9.28e-06
macro iter 2 (3 JK  1 micro), CASSCF E = -99.3843437257381  dE = -1.6271002e-09  S^2 = 0.0000000
               |grad[o]|=0.000182  |grad[c]|= 4.07097920489111e-05  |ddm|=3.07e-06
1-step CASSCF converged in 2 macro (7 JK 3 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99995611 1.99999958 1.99999958 1.02263032 0.97741443]
CASSCF energy = -99.3843437257381
CASCI E = -99.3843437257381  E(CI) = -25.0788503577368  S^2 = 0.0000000
original CI Hamiltonian matrix size .......... 25
after projection on GS irrep, matrix size .... 11
after projection on singlet, matrix size ..... 8
Ground state energy (orig)  -99.3843436732421
Ground state energy (pad)  -99.3843436732421
after padding, matrix size ................... 8
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_hf_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = [['F',(0.0000,0.0000,0.0000)],['H',(0.0000,0.0000, dist)]],
                  basis = 'sto-6g',symmetry = 'coov',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/hf/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/hf_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/hf_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:33:16 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   3.500000000000 AA    0.000000000000   0.000000000000   6.614041435978 Bohr

nuclear repulsion = 1.36074139950857
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:        32.18

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpnupk2di6
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpnupk2di6
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.1875305900461  LUMO (A1) = -0.0294422171042515
Initial guess E= -99.0246183618545  |g|= 1.14122e-06
macro= 0  E= -99.0246183618554  delta_E= -9.09495e-13  |g|= 1.14122e-06  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-99.0246183618554  |g|= 1.14122e-06  total 2 KF 4 JK
converged SCF energy = -99.0246183618554

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpnupk2di6
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -99.3843134243156  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -99.384313457599  dE = -3.328347e-08  S^2 = 0.0000000
               |grad[o]|=0.000881  |grad[c]|= 0.0008095048455814042  |ddm|=9.37e-06
macro iter 2 (3 JK  1 micro), CASSCF E = -99.3843134586369  dE = -1.0378756e-09  S^2 = 0.0000000
               |grad[o]|=0.000152  |grad[c]|= 4.11517286936402e-05  |ddm|=2.46e-06
1-step CASSCF converged in 2 macro (7 JK 3 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99996703 1.99999983 1.99999983 1.01445694 0.98557638]
CASSCF energy = -99.3843134586369
CASCI E = -99.3843134586369  E(CI) = -25.0147263322809  S^2 = 0.0000000
original CI Hamiltonian matrix size .......... 25
after projection on GS irrep, matrix size .... 11
after projection on singlet, matrix size ..... 8
Ground state energy (orig)  -99.3843134243554
Ground state energy (pad)  -99.3843134243554
after padding, matrix size ................... 8
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_hf_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = [['F',(0.0000,0.0000,0.0000)],['H',(0.0000,0.0000, dist)]],
                  basis = 'sto-6g',symmetry = 'coov',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/hf/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/hf_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/hf_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:33:17 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   3.700000000000 AA    0.000000000000   0.000000000000   6.991986660891 Bohr

nuclear repulsion = 1.28718781034595
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:        32.76

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpmqggrbx7
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpmqggrbx7
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.182138742472354  LUMO (A1) = -0.0343391486455454
Initial guess E= -99.0185601194037  |g|= 1.19475e-11
macro= 0  E= -99.0185601194038  delta_E= -2.84217e-14  |g|= 1.19475e-11  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-99.0185601194038  |g|= 1.19475e-11  total 2 KF 4 JK
converged SCF energy = -99.0185601194038

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpmqggrbx7
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -99.3843008777976  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -99.3843009009819  dE = -2.3184342e-08  S^2 = 0.0000000
               |grad[o]|=0.000757  |grad[c]|= 0.000809490582170683  |ddm|=9.21e-06
macro iter 2 (2 JK  1 micro), CASSCF E = -99.3843009016665  dE = -6.8460793e-10  S^2 = 0.0000000
               |grad[o]|=0.000127  |grad[c]|= 3.4949067604909586e-05  |ddm|=1.99e-06
1-step CASSCF converged in 2 macro (6 JK 3 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99997461 1.99999993 1.99999993 1.00921814 0.99080739]
CASSCF energy = -99.3843009016665
CASCI E = -99.3843009016665  E(CI) = -24.9568606497574  S^2 = 0.0000000
original CI Hamiltonian matrix size .......... 25
after projection on GS irrep, matrix size .... 11
after projection on singlet, matrix size ..... 8
Ground state energy (orig)  -99.38430087783937
Ground state energy (pad)  -99.38430087783937
after padding, matrix size ................... 8
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_hf_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = [['F',(0.0000,0.0000,0.0000)],['H',(0.0000,0.0000, dist)]],
                  basis = 'sto-6g',symmetry = 'coov',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/hf/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/hf_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/hf_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:33:17 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   3.900000000000 AA    0.000000000000   0.000000000000   7.369931885804 Bohr

nuclear repulsion = 1.22117817904615
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:        33.38

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpq_x7vc0d
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpq_x7vc0d
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.177586145623986  LUMO (A1) = -0.0385366012948476
Initial guess E= -99.0135862783171  |g|= 1.60044e-11
macro= 0  E= -99.0135862783172  delta_E= -2.84217e-14  |g|= 1.60043e-11  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-99.0135862783172  |g|= 1.60043e-11  total 2 KF 4 JK
converged SCF energy = -99.0135862783172

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpq_x7vc0d
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -99.3842956828733  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -99.3842956999102  dE = -1.7036953e-08  S^2 = 0.0000000
               |grad[o]|=0.00066  |grad[c]|= 0.0008094815827986739  |ddm|=8.89e-06
macro iter 2 (2 JK  1 micro), CASSCF E = -99.3842957003598  dE = -4.4961723e-10  S^2 = 0.0000000
               |grad[o]|=0.000105  |grad[c]|= 3.05704988814974e-05  |ddm|=1.55e-06
1-step CASSCF converged in 2 macro (6 JK 3 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99998003 1.99999997 1.99999997 1.00585988 0.99416014]
CASSCF energy = -99.3842957003598
CASCI E = -99.3842957003598  E(CI) = -24.9050339607057  S^2 = 0.0000000
original CI Hamiltonian matrix size .......... 25
after projection on GS irrep, matrix size .... 11
after projection on singlet, matrix size ..... 8
Ground state energy (orig)  -99.38429568291431
Ground state energy (pad)  -99.38429568291431
after padding, matrix size ................... 8
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_hf_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = [['F',(0.0000,0.0000,0.0000)],['H',(0.0000,0.0000, dist)]],
                  basis = 'sto-6g',symmetry = 'coov',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/hf/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/hf_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/hf_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:33:18 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   4.100000000000 AA    0.000000000000   0.000000000000   7.747877110717 Bohr

nuclear repulsion = 1.16160851177561
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:        33.97

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpmw23jrcz
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpmw23jrcz
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.173672731751752  LUMO (A1) = -0.0421952265705259
Initial guess E= -99.0094080380603  |g|= 1.74373e-11
macro= 0  E= -99.0094080380603  delta_E= -1.42109e-14  |g|= 1.74373e-11  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-99.0094080380603  |g|= 1.74373e-11  total 2 KF 4 JK
converged SCF energy = -99.0094080380603

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpmw23jrcz
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -99.384293536064  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -99.3842935491384  dE = -1.3074413e-08  S^2 = 0.0000000
               |grad[o]|=0.000583  |grad[c]|= 0.0008094757086514381  |ddm|=8.43e-06
macro iter 2 (2 JK  1 micro), CASSCF E = -99.3842935494118  dE = -2.7338842e-10  S^2 = 0.0000000
               |grad[o]|=8.3e-05  |grad[c]|= 2.3315346036895437e-05  |ddm|=1.12e-06
1-step CASSCF converged in 2 macro (6 JK 3 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99998402 1.99999999 1.99999999 1.0037059  0.9963101 ]
CASSCF energy = -99.3842935494118
CASCI E = -99.3842935494118  E(CI) = -24.8578383902893  S^2 = 0.0000000
original CI Hamiltonian matrix size .......... 25
after projection on GS irrep, matrix size .... 11
after projection on singlet, matrix size ..... 8
Ground state energy (orig)  -99.3842935361028
Ground state energy (pad)  -99.3842935361028
after padding, matrix size ................... 8
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_hf_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = [['F',(0.0000,0.0000,0.0000)],['H',(0.0000,0.0000, dist)]],
                  basis = 'sto-6g',symmetry = 'coov',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/hf/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/hf_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/hf_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:33:19 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   4.300000000000 AA    0.000000000000   0.000000000000   8.125822335630 Bohr

nuclear repulsion = 1.10758020890233
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:        34.59

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmptwjxjaq5
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmptwjxjaq5
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.170256252773826  LUMO (A1) = -0.0454285623802469
Initial guess E= -99.0058262661332  |g|= 1.63161e-11
macro= 0  E= -99.0058262661332  delta_E= -1.42109e-14  |g|= 1.6316e-11  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-99.0058262661332  |g|= 1.6316e-11  total 2 KF 4 JK
converged SCF energy = -99.0058262661332

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmptwjxjaq5
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -99.3842926537504  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -99.3842926641387  dE = -1.0388291e-08  S^2 = 0.0000000
               |grad[o]|=0.00052  |grad[c]|= 0.0008094717473018889  |ddm|=7.8e-06
macro iter 2 (2 JK  1 micro), CASSCF E = -99.3842926642659  dE = -1.271161e-10  S^2 = 0.0000000
               |grad[o]|=5.69e-05  |grad[c]|= 1.2697473780674043e-05  |ddm|=6.1e-07
1-step CASSCF converged in 2 macro (6 JK 3 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99998702 2.         2.         1.00232555 0.99768744]
CASSCF energy = -99.3842926642659
CASCI E = -99.3842926642659  E(CI) = -24.8143236623991  S^2 = 0.0000000
original CI Hamiltonian matrix size .......... 25
after projection on GS irrep, matrix size .... 11
after projection on singlet, matrix size ..... 8
Ground state energy (orig)  -99.384292653786
Ground state energy (pad)  -99.384292653786
after padding, matrix size ................... 8
RUNNING VAP_VQE
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/variation_after_projection/circuits/gather_hf_results_cascade.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim,get_orbital_info,permute_orbitals
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE
from VAP_vqe import VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from utils         import *

from qiskit import Aer
from qiskit.chemistry.drivers                      import UnitsType,HFMethodType
from qiskit.chemistry.core                         import Hamiltonian,TransformationType,QubitMappingType
from qiskit.chemistry.components.initial_states    import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.aqua.components.optimizers             import L_BFGS_B,COBYLA,CG
from qiskit.aqua                                   import QuantumInstance,aqua_globals
from qiskit.circuit.library                        import EfficientSU2

def print_circuit(fname,circuit):
    outf = open(fname,'w')
    for gate in circuit:
        gate_name = gate[0].name
        qubits = [q.index for q in gate[1]]
        outf.write(str(gate_name)+' | '+' '.join([str(x) for x in qubits])+' | '+' '.join([str(x._symbol_expr) for x in gate[0].params])+'\n')
    outf.close()

def print_results(fname,res_vqe,res_ee,dN=0):
    outf = open(fname,'w')
    outf.write('%.12f %.12f \n' % (res_vqe[0],np.real(res_ee[0])))
    outf.write('%.12f %.12f \n' % (res_vqe[1],np.real(res_ee[1])))
    outf.write('%.12f %.12f \n' % (res_vqe[2],np.real(res_ee[2])))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]
depth_list = [3,4,5]

for depth in depth_list:
    for dist in dist_list:
        rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
        rho  = rho[str(dist)]['rho_scf']
        mol = gto.Mole()
        mol.build(atom  = [['F',(0.0000,0.0000,0.0000)],['H',(0.0000,0.0000, dist)]],
                  basis = 'sto-6g',symmetry = 'coov',spin = 0,charge = 0,verbose = 4)
        mf       = scf.RHF(mol)
        mf       = scf.newton(mf)
        mf.kernel(rho)

        orb_info = get_orbital_info(mf)
        H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
        S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
        print("original CI Hamiltonian matrix size ..........",H_fci.shape[0])
        
        H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
        print("after projection on GS irrep, matrix size ....",H_fci.shape[0])
        
        H_fci,S_fci = project_along_singlet(H_fci,S_fci)
        print("after projection on singlet, matrix size .....",H_fci.shape[0])
        
        H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
        print("after padding, matrix size ...................",H_fci.shape[0])
        
        H_op = matrix_to_qubit_operator(H_fci)
        P = matrix_to_qubit_operator(Proj)
        J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))
        A_op = [P,J]

        var_form = make_cascade_ansatz(nqubit,layers=depth)
        p0 = np.loadtxt('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad_VAP/hf/cascade_depth_%d/R_%s/output_parameters.txt'%(depth,str(dist)))
        optimizer = COBYLA(maxiter=0)
        algo      = VQE(H_op,var_form,optimizer,aux_operators=A_op,include_custom=True,initial_point=p0)
        backend          = Aer.get_backend('statevector_simulator')
        quantum_instance = QuantumInstance(backend=backend)
        algo_result      = algo.run(quantum_instance)
       
        p1 = algo._ret['opt_params']
        outfile = open('cascade_results.txt','w')
        res_vqe,res_ee = get_results_first_quantization(H_op,A_op,algo_result,outfile)
        print_results('cascade_%d/hf_%s_results.txt' % (depth,str(dist)),res_vqe,res_ee)
        circuit = var_form.bind_parameters(p1)
        print_circuit('cascade_%d/hf_%s_circuit.txt' % (depth,str(dist)),circuit)
 
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:33:19 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   4.500000000000 AA    0.000000000000   0.000000000000   8.503767560543 Bohr

nuclear repulsion = 1.05835442184
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:        35.21

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpj5xaf4s2
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpj5xaf4s2
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.167234340444411  LUMO (A1) = -0.0483184486891664
Initial guess E= -99.0027023161739  |g|= 1.34179e-11
macro= 0  E= -99.0027023161739  delta_E= -1.42109e-14  |g|= 1.34179e-11  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-99.0027023161739  |g|= 1.34179e-11  total 2 KF 4 JK
converged SCF energy = -99.0027023161739

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpj5xaf4s2
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -99.3842922953184  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (3 JK  1 micro), CASSCF E = -99.3842923037888  dE = -8.4704368e-09  S^2 = 0.0000000
               |grad[o]|=0.000469  |grad[c]|= 0.0008094865379269299  |ddm|=6.93e-06
macro iter 2 (1 JK  1 micro), CASSCF E = -99.3842923037888  dE = -2.8421709e-14  S^2 = 0.0000000
               |grad[o]|=2e-05  |grad[c]|= 4.7066442559533194e-07  |ddm|=    0
1-step CASSCF converged in 2 macro (4 JK 2 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99998932 2.         2.         1.00144421 0.99856648]
CASSCF energy = -99.3842923037888
CASCI E = -99.3842923037888  E(CI) = -24.7722866885594  S^2 = 0.0000000
original CI Hamiltonian matrix size .......... 25
after projection on GS irrep, matrix size .... 11
after projection on singlet, matrix size ..... 8
Ground state energy (orig)  -99.38429229535043
Ground state energy (pad)  -99.38429229535043
after padding, matrix size ................... 8
RUNNING VAP_VQE
