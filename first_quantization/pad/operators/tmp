#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/operators/gather_hf_operators.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from scipy import linalg as LA
from utils import *

def geometry(d):
    z0 = 0.1177
    z1 = 0.47116
    y0 = 0.75545
    r0 = np.sqrt(y0**2+(z0+z1)**2)
    r  = d/r0
    return "O 0.0000 0.0000 {0}; H 0.0000 {1} -{2}; H 0.0000 -{1} -{2}".format(z0*r,y0*r,z1*r)

def write_to_file(X,dX,fname):
    outf = open(fname,'w')
    for c,P in X._paulis:
        P = P.to_label()
        if(P=='I'*X.num_qubits):
           c += dX
        outf.write('%s %.12f\n' % (P,c.real))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]

info = []
for dist in dist_list:
    rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
    rho  = rho[str(dist)]['rho_scf']
    
    mol = gto.Mole()
    mol.build(atom     = [['F',(0.0000,0.0000,0.0000)],
                          ['H',(0.0000,0.0000, dist)]],
              basis    = 'sto-6g',
              symmetry = 'coov',
              spin     = 0,
              charge   = 0,
              verbose  = 4)
    mf       = scf.RHF(mol)
    mf       = scf.newton(mf)
    mf.kernel(rho)

    H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
    S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
    d1 = H_fci.shape[0]
    e1 = LA.eigh(H_fci)[0][0]

    H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
    d2 = H_fci.shape[0]
    
    H_fci,S_fci = project_along_singlet(H_fci,S_fci)
    d3 = H_fci.shape[0]
    
    H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
    print("after padding, matrix size ...................",H_fci.shape[0])
    d4 = H_fci.shape[0]
    e4 = LA.eigh(H_fci)[0][0]

    H_op = matrix_to_qubit_operator(H_fci)
    H_op = matrix_to_qubit_operator(H_fci)
    P = matrix_to_qubit_operator(Proj)
    J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))

    write_to_file(H_op,0,'hf_%s_h.txt'%dist)
    write_to_file(P,0,'hf_%s_p.txt'%dist)
    write_to_file(J,0,'hf_%s_php.txt'%dist)

    info.append([d1,d2,d3,d4,e1,e4])

outf = open('hf_info.txt','w')
for d1,d2,d3,d4,e1,e4 in info:
    outf.write('%d %d %d %d %.12f %.12f \n' % (d1,d2,d3,d4,e1,e4))
outf.close()

#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:20:08 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   0.500000000000 AA    0.000000000000   0.000000000000   0.944863062283 Bohr

nuclear repulsion = 9.52518979656
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:         4.28

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp8lirf6wk
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp8lirf6wk
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (E1y) = -0.542449098513258  LUMO (A1) = 1.06641683472435
Initial guess E= -98.6431706488635  |g|= 5.92553e-11
macro= 0  E= -98.6431706488635  delta_E= -7.10543e-14  |g|= 5.92553e-11  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-98.6431706488635  |g|= 5.92553e-11  total 2 KF 4 JK
converged SCF energy = -98.6431706488635

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp8lirf6wk
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -98.6492586392853  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (3 JK  1 micro), CASSCF E = -98.649259227325  dE = -5.880397e-07  S^2 = 0.0000000
               |grad[o]|=0.000996  |grad[c]|= 0.0005598508699383355  |ddm|=1.43e-05
macro iter 2 (1 JK  1 micro), CASSCF E = -98.6492592273519  dE = -2.6915359e-11  S^2 = 0.0000000
               |grad[o]|=3.43e-06  |grad[c]|= 8.90228249604693e-06  |ddm|=4.72e-06
1-step CASSCF converged in 2 macro (4 JK 2 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99852367 1.9987067  1.99964162 1.99964162 0.00348639]
CASSCF energy = -98.6492592273519
CASCI E = -98.6492592273519  E(CI) = -30.6193134261933  S^2 = 0.0000000
Ground state energy (orig)  -98.64925863928661
Ground state energy (pad)  -98.64925863928661
after padding, matrix size ................... 8
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/operators/gather_hf_operators.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from scipy import linalg as LA
from utils import *

def geometry(d):
    z0 = 0.1177
    z1 = 0.47116
    y0 = 0.75545
    r0 = np.sqrt(y0**2+(z0+z1)**2)
    r  = d/r0
    return "O 0.0000 0.0000 {0}; H 0.0000 {1} -{2}; H 0.0000 -{1} -{2}".format(z0*r,y0*r,z1*r)

def write_to_file(X,dX,fname):
    outf = open(fname,'w')
    for c,P in X._paulis:
        P = P.to_label()
        if(P=='I'*X.num_qubits):
           c += dX
        outf.write('%s %.12f\n' % (P,c.real))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]

info = []
for dist in dist_list:
    rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
    rho  = rho[str(dist)]['rho_scf']
    
    mol = gto.Mole()
    mol.build(atom     = [['F',(0.0000,0.0000,0.0000)],
                          ['H',(0.0000,0.0000, dist)]],
              basis    = 'sto-6g',
              symmetry = 'coov',
              spin     = 0,
              charge   = 0,
              verbose  = 4)
    mf       = scf.RHF(mol)
    mf       = scf.newton(mf)
    mf.kernel(rho)

    H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
    S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
    d1 = H_fci.shape[0]
    e1 = LA.eigh(H_fci)[0][0]

    H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
    d2 = H_fci.shape[0]
    
    H_fci,S_fci = project_along_singlet(H_fci,S_fci)
    d3 = H_fci.shape[0]
    
    H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
    print("after padding, matrix size ...................",H_fci.shape[0])
    d4 = H_fci.shape[0]
    e4 = LA.eigh(H_fci)[0][0]

    H_op = matrix_to_qubit_operator(H_fci)
    H_op = matrix_to_qubit_operator(H_fci)
    P = matrix_to_qubit_operator(Proj)
    J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))

    write_to_file(H_op,0,'hf_%s_h.txt'%dist)
    write_to_file(P,0,'hf_%s_p.txt'%dist)
    write_to_file(J,0,'hf_%s_php.txt'%dist)

    info.append([d1,d2,d3,d4,e1,e4])

outf = open('hf_info.txt','w')
for d1,d2,d3,d4,e1,e4 in info:
    outf.write('%d %d %d %d %.12f %.12f \n' % (d1,d2,d3,d4,e1,e4))
outf.close()

#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:20:08 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   0.700000000000 AA    0.000000000000   0.000000000000   1.322808287196 Bohr

nuclear repulsion = 6.80370699754286
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:         4.54

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp3zshmsz2
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp3zshmsz2
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (E1y) = -0.491898144886808  LUMO (A1) = 0.870096594297086
Initial guess E= -99.3566943727443  |g|= 2.50204e-11
macro= 0  E= -99.3566943727443  delta_E= 0  |g|= 2.50205e-11  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-99.3566943727443  |g|= 2.50205e-11  total 2 KF 4 JK
converged SCF energy = -99.3566943727443

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp3zshmsz2
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -99.3698359392924  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -99.3698412952461  dE = -5.3559537e-06  S^2 = 0.0000000
               |grad[o]|=0.00133  |grad[c]|= 0.0010950503430339146  |ddm|=8.24e-05
macro iter 2 (3 JK  1 micro), CASSCF E = -99.3698415927433  dE = -2.9749722e-07  S^2 = 0.0000000
               |grad[o]|=0.000312  |grad[c]|= 0.00013897282844079525  |ddm|=1.37e-05
macro iter 3 (1 JK  1 micro), CASSCF E = -99.3698415927551  dE = -1.1795009e-11  S^2 = 0.0000000
               |grad[o]|=7.08e-06  |grad[c]|= 4.926788526260813e-06  |ddm|=4.84e-06
1-step CASSCF converged in 3 macro (8 JK 4 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99743283 1.99313824 1.99953236 1.99953236 0.01036422]
CASSCF energy = -99.3698415927551
CASCI E = -99.3698415927551  E(CI) = -29.2456901425531  S^2 = 0.0000000
Ground state energy (orig)  -99.3698359392973
Ground state energy (pad)  -99.3698359392973
after padding, matrix size ................... 8
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/operators/gather_hf_operators.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from scipy import linalg as LA
from utils import *

def geometry(d):
    z0 = 0.1177
    z1 = 0.47116
    y0 = 0.75545
    r0 = np.sqrt(y0**2+(z0+z1)**2)
    r  = d/r0
    return "O 0.0000 0.0000 {0}; H 0.0000 {1} -{2}; H 0.0000 -{1} -{2}".format(z0*r,y0*r,z1*r)

def write_to_file(X,dX,fname):
    outf = open(fname,'w')
    for c,P in X._paulis:
        P = P.to_label()
        if(P=='I'*X.num_qubits):
           c += dX
        outf.write('%s %.12f\n' % (P,c.real))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]

info = []
for dist in dist_list:
    rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
    rho  = rho[str(dist)]['rho_scf']
    
    mol = gto.Mole()
    mol.build(atom     = [['F',(0.0000,0.0000,0.0000)],
                          ['H',(0.0000,0.0000, dist)]],
              basis    = 'sto-6g',
              symmetry = 'coov',
              spin     = 0,
              charge   = 0,
              verbose  = 4)
    mf       = scf.RHF(mol)
    mf       = scf.newton(mf)
    mf.kernel(rho)

    H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
    S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
    d1 = H_fci.shape[0]
    e1 = LA.eigh(H_fci)[0][0]

    H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
    d2 = H_fci.shape[0]
    
    H_fci,S_fci = project_along_singlet(H_fci,S_fci)
    d3 = H_fci.shape[0]
    
    H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
    print("after padding, matrix size ...................",H_fci.shape[0])
    d4 = H_fci.shape[0]
    e4 = LA.eigh(H_fci)[0][0]

    H_op = matrix_to_qubit_operator(H_fci)
    H_op = matrix_to_qubit_operator(H_fci)
    P = matrix_to_qubit_operator(Proj)
    J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))

    write_to_file(H_op,0,'hf_%s_h.txt'%dist)
    write_to_file(P,0,'hf_%s_p.txt'%dist)
    write_to_file(J,0,'hf_%s_php.txt'%dist)

    info.append([d1,d2,d3,d4,e1,e4])

outf = open('hf_info.txt','w')
for d1,d2,d3,d4,e1,e4 in info:
    outf.write('%d %d %d %d %.12f %.12f \n' % (d1,d2,d3,d4,e1,e4))
outf.close()

#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:20:08 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   0.900000000000 AA    0.000000000000   0.000000000000   1.700753512109 Bohr

nuclear repulsion = 5.2917721092
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:         4.81

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp7009ob0p
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp7009ob0p
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (E1y) = -0.474217951730683  LUMO (A1) = 0.635290303157671
Initial guess E= -99.4976185399225  |g|= 2.34849e-10
macro= 0  E= -99.4976185399225  delta_E= -4.26326e-14  |g|= 2.34849e-10  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-99.4976185399225  |g|= 2.34849e-10  total 2 KF 4 JK
converged SCF energy = -99.4976185399225

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp7009ob0p
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -99.5222999464251  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -99.5223100259103  dE = -1.0079485e-05  S^2 = 0.0000000
               |grad[o]|=0.00167  |grad[c]|= 0.000904811459949087  |ddm|=9.02e-05
macro iter 2 (3 JK  1 micro), CASSCF E = -99.5223110352229  dE = -1.0093126e-06  S^2 = 0.0000000
               |grad[o]|=0.000509  |grad[c]|= 0.00023203582563628198  |ddm|=2.62e-05
macro iter 3 (1 JK  1 micro), CASSCF E = -99.5223110352252  dE = -2.3590019e-12  S^2 = 0.0000000
               |grad[o]|=7.79e-06  |grad[c]|= 2.1252507155751018e-06  |ddm|=8.45e-07
1-step CASSCF converged in 3 macro (8 JK 4 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99698639 1.97626122 1.99942733 1.99942733 0.02789773]
CASSCF energy = -99.5223110352252
CASCI E = -99.5223110352252  E(CI) = -28.2225882143454  S^2 = 0.0000000
Ground state energy (orig)  -99.52229994642516
Ground state energy (pad)  -99.52229994642516
after padding, matrix size ................... 8
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/operators/gather_hf_operators.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from scipy import linalg as LA
from utils import *

def geometry(d):
    z0 = 0.1177
    z1 = 0.47116
    y0 = 0.75545
    r0 = np.sqrt(y0**2+(z0+z1)**2)
    r  = d/r0
    return "O 0.0000 0.0000 {0}; H 0.0000 {1} -{2}; H 0.0000 -{1} -{2}".format(z0*r,y0*r,z1*r)

def write_to_file(X,dX,fname):
    outf = open(fname,'w')
    for c,P in X._paulis:
        P = P.to_label()
        if(P=='I'*X.num_qubits):
           c += dX
        outf.write('%s %.12f\n' % (P,c.real))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]

info = []
for dist in dist_list:
    rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
    rho  = rho[str(dist)]['rho_scf']
    
    mol = gto.Mole()
    mol.build(atom     = [['F',(0.0000,0.0000,0.0000)],
                          ['H',(0.0000,0.0000, dist)]],
              basis    = 'sto-6g',
              symmetry = 'coov',
              spin     = 0,
              charge   = 0,
              verbose  = 4)
    mf       = scf.RHF(mol)
    mf       = scf.newton(mf)
    mf.kernel(rho)

    H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
    S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
    d1 = H_fci.shape[0]
    e1 = LA.eigh(H_fci)[0][0]

    H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
    d2 = H_fci.shape[0]
    
    H_fci,S_fci = project_along_singlet(H_fci,S_fci)
    d3 = H_fci.shape[0]
    
    H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
    print("after padding, matrix size ...................",H_fci.shape[0])
    d4 = H_fci.shape[0]
    e4 = LA.eigh(H_fci)[0][0]

    H_op = matrix_to_qubit_operator(H_fci)
    H_op = matrix_to_qubit_operator(H_fci)
    P = matrix_to_qubit_operator(Proj)
    J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))

    write_to_file(H_op,0,'hf_%s_h.txt'%dist)
    write_to_file(P,0,'hf_%s_p.txt'%dist)
    write_to_file(J,0,'hf_%s_php.txt'%dist)

    info.append([d1,d2,d3,d4,e1,e4])

outf = open('hf_info.txt','w')
for d1,d2,d3,d4,e1,e4 in info:
    outf.write('%d %d %d %d %.12f %.12f \n' % (d1,d2,d3,d4,e1,e4))
outf.close()

#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:20:09 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   1.100000000000 AA    0.000000000000   0.000000000000   2.078698737022 Bohr

nuclear repulsion = 4.32963172570909
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:         5.08

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpb2gmywj2
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpb2gmywj2
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (E1y) = -0.471164828789002  LUMO (A1) = 0.450722667315901
Initial guess E= -99.4811742748041  |g|= 1.75641e-10
macro= 0  E= -99.4811742748041  delta_E= 0  |g|= 1.75641e-10  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-99.4811742748041  |g|= 1.75641e-10  total 2 KF 4 JK
converged SCF energy = -99.4811742748041

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpb2gmywj2
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -99.524178552469  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -99.5241907712433  dE = -1.2218774e-05  S^2 = 0.0000000
               |grad[o]|=0.002  |grad[c]|= 0.0008443495095501067  |ddm|=8.77e-05
macro iter 2 (3 JK  1 micro), CASSCF E = -99.5241918378397  dE = -1.0665964e-06  S^2 = 0.0000000
               |grad[o]|=0.000572  |grad[c]|= 0.00020108970908869209  |ddm|=2.47e-05
macro iter 3 (1 JK  1 micro), CASSCF E = -99.5241918378756  dE = -3.5939252e-11  S^2 = 0.0000000
               |grad[o]|=1.22e-05  |grad[c]|= 7.987384267988116e-06  |ddm|=8.5e-06
1-step CASSCF converged in 3 macro (8 JK 4 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99725266 1.93653157 1.99937227 1.99937227 0.06747124]
CASSCF energy = -99.5241918378756
CASCI E = -99.5241918378756  E(CI) = -27.4720961063268  S^2 = 0.0000000
Ground state energy (orig)  -99.52417855250823
Ground state energy (pad)  -99.52417855250823
after padding, matrix size ................... 8
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/operators/gather_hf_operators.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from scipy import linalg as LA
from utils import *

def geometry(d):
    z0 = 0.1177
    z1 = 0.47116
    y0 = 0.75545
    r0 = np.sqrt(y0**2+(z0+z1)**2)
    r  = d/r0
    return "O 0.0000 0.0000 {0}; H 0.0000 {1} -{2}; H 0.0000 -{1} -{2}".format(z0*r,y0*r,z1*r)

def write_to_file(X,dX,fname):
    outf = open(fname,'w')
    for c,P in X._paulis:
        P = P.to_label()
        if(P=='I'*X.num_qubits):
           c += dX
        outf.write('%s %.12f\n' % (P,c.real))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]

info = []
for dist in dist_list:
    rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
    rho  = rho[str(dist)]['rho_scf']
    
    mol = gto.Mole()
    mol.build(atom     = [['F',(0.0000,0.0000,0.0000)],
                          ['H',(0.0000,0.0000, dist)]],
              basis    = 'sto-6g',
              symmetry = 'coov',
              spin     = 0,
              charge   = 0,
              verbose  = 4)
    mf       = scf.RHF(mol)
    mf       = scf.newton(mf)
    mf.kernel(rho)

    H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
    S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
    d1 = H_fci.shape[0]
    e1 = LA.eigh(H_fci)[0][0]

    H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
    d2 = H_fci.shape[0]
    
    H_fci,S_fci = project_along_singlet(H_fci,S_fci)
    d3 = H_fci.shape[0]
    
    H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
    print("after padding, matrix size ...................",H_fci.shape[0])
    d4 = H_fci.shape[0]
    e4 = LA.eigh(H_fci)[0][0]

    H_op = matrix_to_qubit_operator(H_fci)
    H_op = matrix_to_qubit_operator(H_fci)
    P = matrix_to_qubit_operator(Proj)
    J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))

    write_to_file(H_op,0,'hf_%s_h.txt'%dist)
    write_to_file(P,0,'hf_%s_p.txt'%dist)
    write_to_file(J,0,'hf_%s_php.txt'%dist)

    info.append([d1,d2,d3,d4,e1,e4])

outf = open('hf_info.txt','w')
for d1,d2,d3,d4,e1,e4 in info:
    outf.write('%d %d %d %d %.12f %.12f \n' % (d1,d2,d3,d4,e1,e4))
outf.close()

#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:20:09 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   1.300000000000 AA    0.000000000000   0.000000000000   2.456643961935 Bohr

nuclear repulsion = 3.66353453713846
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:         5.36

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpdqhugtwt
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpdqhugtwt
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (E1y) = -0.472630543991933  LUMO (A1) = 0.316375293476612
Initial guess E= -99.4175531085697  |g|= 3.10423e-10
macro= 0  E= -99.4175531085697  delta_E= 1.42109e-14  |g|= 3.10423e-10  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-99.4175531085697  |g|= 3.10423e-10  total 2 KF 4 JK
converged SCF energy = -99.4175531085697

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpdqhugtwt
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -99.4873310609179  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -99.4873426593609  dE = -1.1598443e-05  S^2 = 0.0000000
               |grad[o]|=0.00232  |grad[c]|= 0.0008251879140132316  |ddm|=7.2e-05
macro iter 2 (2 JK  1 micro), CASSCF E = -99.4873434457746  dE = -7.8641366e-07  S^2 = 0.0000000
               |grad[o]|=0.000586  |grad[c]|= 0.00015620023813076058  |ddm|=2.16e-05
macro iter 3 (1 JK  1 micro), CASSCF E = -99.4873434457918  dE = -1.7237767e-11  S^2 = 0.0000000
               |grad[o]|=1.07e-05  |grad[c]|= 5.552256702158863e-06  |ddm|=5.77e-06
1-step CASSCF converged in 3 macro (7 JK 4 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.9978254  1.85986869 1.99940701 1.99940701 0.1434919 ]
CASSCF energy = -99.4873434457918
CASCI E = -99.4873434457918  E(CI) = -26.9139463073601  S^2 = 0.0000000
Ground state energy (orig)  -99.48733106092097
Ground state energy (pad)  -99.48733106092097
after padding, matrix size ................... 8
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/operators/gather_hf_operators.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from scipy import linalg as LA
from utils import *

def geometry(d):
    z0 = 0.1177
    z1 = 0.47116
    y0 = 0.75545
    r0 = np.sqrt(y0**2+(z0+z1)**2)
    r  = d/r0
    return "O 0.0000 0.0000 {0}; H 0.0000 {1} -{2}; H 0.0000 -{1} -{2}".format(z0*r,y0*r,z1*r)

def write_to_file(X,dX,fname):
    outf = open(fname,'w')
    for c,P in X._paulis:
        P = P.to_label()
        if(P=='I'*X.num_qubits):
           c += dX
        outf.write('%s %.12f\n' % (P,c.real))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]

info = []
for dist in dist_list:
    rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
    rho  = rho[str(dist)]['rho_scf']
    
    mol = gto.Mole()
    mol.build(atom     = [['F',(0.0000,0.0000,0.0000)],
                          ['H',(0.0000,0.0000, dist)]],
              basis    = 'sto-6g',
              symmetry = 'coov',
              spin     = 0,
              charge   = 0,
              verbose  = 4)
    mf       = scf.RHF(mol)
    mf       = scf.newton(mf)
    mf.kernel(rho)

    H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
    S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
    d1 = H_fci.shape[0]
    e1 = LA.eigh(H_fci)[0][0]

    H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
    d2 = H_fci.shape[0]
    
    H_fci,S_fci = project_along_singlet(H_fci,S_fci)
    d3 = H_fci.shape[0]
    
    H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
    print("after padding, matrix size ...................",H_fci.shape[0])
    d4 = H_fci.shape[0]
    e4 = LA.eigh(H_fci)[0][0]

    H_op = matrix_to_qubit_operator(H_fci)
    H_op = matrix_to_qubit_operator(H_fci)
    P = matrix_to_qubit_operator(Proj)
    J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))

    write_to_file(H_op,0,'hf_%s_h.txt'%dist)
    write_to_file(P,0,'hf_%s_p.txt'%dist)
    write_to_file(J,0,'hf_%s_php.txt'%dist)

    info.append([d1,d2,d3,d4,e1,e4])

outf = open('hf_info.txt','w')
for d1,d2,d3,d4,e1,e4 in info:
    outf.write('%d %d %d %d %.12f %.12f \n' % (d1,d2,d3,d4,e1,e4))
outf.close()

#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:20:09 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   1.500000000000 AA    0.000000000000   0.000000000000   2.834589186848 Bohr

nuclear repulsion = 3.17506326552
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:         5.63

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpt9vf7_5e
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpt9vf7_5e
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.416857352082889  LUMO (A1) = 0.219769848446538
Initial guess E= -99.3430560539903  |g|= 3.26563e-09
macro= 0  E= -99.3430560539903  delta_E= -1.42109e-14  |g|= 3.26563e-09  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-99.3430560539903  |g|= 3.26563e-09  total 2 KF 4 JK
converged SCF energy = -99.3430560539903

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpt9vf7_5e
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -99.4483488824887  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -99.448357995438  dE = -9.1129493e-06  S^2 = 0.0000000
               |grad[o]|=0.00274  |grad[c]|= 0.0008183706265176677  |ddm|=5.65e-05
macro iter 2 (2 JK  1 micro), CASSCF E = -99.4483584825531  dE = -4.8711512e-07  S^2 = 0.0000000
               |grad[o]|=0.000616  |grad[c]|= 0.00011798015456237586  |ddm|=1.88e-05
macro iter 3 (1 JK  1 micro), CASSCF E = -99.4483584825608  dE = -7.6596507e-12  S^2 = 0.0000000
               |grad[o]|=8.68e-06  |grad[c]|= 3.5851155092078285e-06  |ddm|=3.77e-06
1-step CASSCF converged in 3 macro (7 JK 4 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99840144 1.99953554 1.99953554 1.73828215 0.26424534]
CASSCF energy = -99.4483584825608
CASCI E = -99.4483584825608  E(CI) = -26.4929234379962  S^2 = 0.0000000
Ground state energy (orig)  -99.44834888249717
Ground state energy (pad)  -99.44834888249717
after padding, matrix size ................... 8
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/operators/gather_hf_operators.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from scipy import linalg as LA
from utils import *

def geometry(d):
    z0 = 0.1177
    z1 = 0.47116
    y0 = 0.75545
    r0 = np.sqrt(y0**2+(z0+z1)**2)
    r  = d/r0
    return "O 0.0000 0.0000 {0}; H 0.0000 {1} -{2}; H 0.0000 -{1} -{2}".format(z0*r,y0*r,z1*r)

def write_to_file(X,dX,fname):
    outf = open(fname,'w')
    for c,P in X._paulis:
        P = P.to_label()
        if(P=='I'*X.num_qubits):
           c += dX
        outf.write('%s %.12f\n' % (P,c.real))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]

info = []
for dist in dist_list:
    rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
    rho  = rho[str(dist)]['rho_scf']
    
    mol = gto.Mole()
    mol.build(atom     = [['F',(0.0000,0.0000,0.0000)],
                          ['H',(0.0000,0.0000, dist)]],
              basis    = 'sto-6g',
              symmetry = 'coov',
              spin     = 0,
              charge   = 0,
              verbose  = 4)
    mf       = scf.RHF(mol)
    mf       = scf.newton(mf)
    mf.kernel(rho)

    H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
    S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
    d1 = H_fci.shape[0]
    e1 = LA.eigh(H_fci)[0][0]

    H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
    d2 = H_fci.shape[0]
    
    H_fci,S_fci = project_along_singlet(H_fci,S_fci)
    d3 = H_fci.shape[0]
    
    H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
    print("after padding, matrix size ...................",H_fci.shape[0])
    d4 = H_fci.shape[0]
    e4 = LA.eigh(H_fci)[0][0]

    H_op = matrix_to_qubit_operator(H_fci)
    H_op = matrix_to_qubit_operator(H_fci)
    P = matrix_to_qubit_operator(Proj)
    J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))

    write_to_file(H_op,0,'hf_%s_h.txt'%dist)
    write_to_file(P,0,'hf_%s_p.txt'%dist)
    write_to_file(J,0,'hf_%s_php.txt'%dist)

    info.append([d1,d2,d3,d4,e1,e4])

outf = open('hf_info.txt','w')
for d1,d2,d3,d4,e1,e4 in info:
    outf.write('%d %d %d %d %.12f %.12f \n' % (d1,d2,d3,d4,e1,e4))
outf.close()

#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:20:09 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   1.700000000000 AA    0.000000000000   0.000000000000   3.212534411761 Bohr

nuclear repulsion = 2.80152641075294
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:         5.90

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpmp7krglz
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpmp7krglz
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.366580870358538  LUMO (A1) = 0.150293177157103
Initial guess E= -99.2721536741672  |g|= 5.3505e-11
macro= 0  E= -99.2721536741672  delta_E= 1.42109e-14  |g|= 5.3505e-11  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-99.2721536741672  |g|= 5.3505e-11  total 2 KF 4 JK
converged SCF energy = -99.2721536741672

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpmp7krglz
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -99.4193986920378  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -99.4194047843789  dE = -6.0923411e-06  S^2 = 0.0000000
               |grad[o]|=0.00317  |grad[c]|= 0.0008149330895020841  |ddm|=4.51e-05
macro iter 2 (2 JK  1 micro), CASSCF E = -99.4194050560302  dE = -2.7165122e-07  S^2 = 0.0000000
               |grad[o]|=0.000651  |grad[c]|= 8.89983380040323e-05  |ddm|=1.69e-05
macro iter 3 (1 JK  1 micro), CASSCF E = -99.4194050560331  dE = -2.9700686e-12  S^2 = 0.0000000
               |grad[o]|=7.72e-06  |grad[c]|= 2.1976804404875995e-06  |ddm|=2.25e-06
1-step CASSCF converged in 3 macro (7 JK 4 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99888784 1.99970267 1.99970267 1.58404843 0.41765839]
CASSCF energy = -99.4194050560331
CASCI E = -99.4194050560331  E(CI) = -26.1721396630326  S^2 = 0.0000000
Ground state energy (orig)  -99.41939869206347
Ground state energy (pad)  -99.41939869206347
after padding, matrix size ................... 8
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/operators/gather_hf_operators.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from scipy import linalg as LA
from utils import *

def geometry(d):
    z0 = 0.1177
    z1 = 0.47116
    y0 = 0.75545
    r0 = np.sqrt(y0**2+(z0+z1)**2)
    r  = d/r0
    return "O 0.0000 0.0000 {0}; H 0.0000 {1} -{2}; H 0.0000 -{1} -{2}".format(z0*r,y0*r,z1*r)

def write_to_file(X,dX,fname):
    outf = open(fname,'w')
    for c,P in X._paulis:
        P = P.to_label()
        if(P=='I'*X.num_qubits):
           c += dX
        outf.write('%s %.12f\n' % (P,c.real))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]

info = []
for dist in dist_list:
    rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
    rho  = rho[str(dist)]['rho_scf']
    
    mol = gto.Mole()
    mol.build(atom     = [['F',(0.0000,0.0000,0.0000)],
                          ['H',(0.0000,0.0000, dist)]],
              basis    = 'sto-6g',
              symmetry = 'coov',
              spin     = 0,
              charge   = 0,
              verbose  = 4)
    mf       = scf.RHF(mol)
    mf       = scf.newton(mf)
    mf.kernel(rho)

    H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
    S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
    d1 = H_fci.shape[0]
    e1 = LA.eigh(H_fci)[0][0]

    H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
    d2 = H_fci.shape[0]
    
    H_fci,S_fci = project_along_singlet(H_fci,S_fci)
    d3 = H_fci.shape[0]
    
    H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
    print("after padding, matrix size ...................",H_fci.shape[0])
    d4 = H_fci.shape[0]
    e4 = LA.eigh(H_fci)[0][0]

    H_op = matrix_to_qubit_operator(H_fci)
    H_op = matrix_to_qubit_operator(H_fci)
    P = matrix_to_qubit_operator(Proj)
    J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))

    write_to_file(H_op,0,'hf_%s_h.txt'%dist)
    write_to_file(P,0,'hf_%s_p.txt'%dist)
    write_to_file(J,0,'hf_%s_php.txt'%dist)

    info.append([d1,d2,d3,d4,e1,e4])

outf = open('hf_info.txt','w')
for d1,d2,d3,d4,e1,e4 in info:
    outf.write('%d %d %d %d %.12f %.12f \n' % (d1,d2,d3,d4,e1,e4))
outf.close()

#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:20:10 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   1.900000000000 AA    0.000000000000   0.000000000000   3.590479636674 Bohr

nuclear repulsion = 2.50662889383158
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:         6.18

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpea2o55fl
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpea2o55fl
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.324314779627263  LUMO (A1) = 0.100249398857483
Initial guess E= -99.2109791084948  |g|= 2.83825e-08
macro= 0  E= -99.2109791084948  delta_E= 0  |g|= 2.83825e-08  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-99.2109791084948  |g|= 2.83825e-08  total 2 KF 4 JK
converged SCF energy = -99.2109791084948

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpea2o55fl
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -99.4018220434628  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -99.4018256327789  dE = -3.589316e-06  S^2 = 0.0000000
               |grad[o]|=0.00333  |grad[c]|= 0.0008127225449384163  |ddm|=3.68e-05
macro iter 2 (2 JK  1 micro), CASSCF E = -99.4018257747526  dE = -1.4197371e-07  S^2 = 0.0000000
               |grad[o]|=0.000645  |grad[c]|= 6.889395347937303e-05  |ddm|=1.53e-05
macro iter 3 (1 JK  1 micro), CASSCF E = -99.4018257747537  dE = -1.1226575e-12  S^2 = 0.0000000
               |grad[o]|=6.79e-06  |grad[c]|= 1.3499115157567212e-06  |ddm|=1.31e-06
1-step CASSCF converged in 3 macro (7 JK 4 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99926506 1.9998398  1.9998398  1.42815212 0.57290322]
CASSCF energy = -99.4018257747537
CASCI E = -99.4018257747537  E(CI) = -25.9244298827281  S^2 = 0.0000000
Ground state energy (orig)  -99.40182204346284
Ground state energy (pad)  -99.40182204346284
after padding, matrix size ................... 8
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/operators/gather_hf_operators.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from scipy import linalg as LA
from utils import *

def geometry(d):
    z0 = 0.1177
    z1 = 0.47116
    y0 = 0.75545
    r0 = np.sqrt(y0**2+(z0+z1)**2)
    r  = d/r0
    return "O 0.0000 0.0000 {0}; H 0.0000 {1} -{2}; H 0.0000 -{1} -{2}".format(z0*r,y0*r,z1*r)

def write_to_file(X,dX,fname):
    outf = open(fname,'w')
    for c,P in X._paulis:
        P = P.to_label()
        if(P=='I'*X.num_qubits):
           c += dX
        outf.write('%s %.12f\n' % (P,c.real))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]

info = []
for dist in dist_list:
    rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
    rho  = rho[str(dist)]['rho_scf']
    
    mol = gto.Mole()
    mol.build(atom     = [['F',(0.0000,0.0000,0.0000)],
                          ['H',(0.0000,0.0000, dist)]],
              basis    = 'sto-6g',
              symmetry = 'coov',
              spin     = 0,
              charge   = 0,
              verbose  = 4)
    mf       = scf.RHF(mol)
    mf       = scf.newton(mf)
    mf.kernel(rho)

    H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
    S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
    d1 = H_fci.shape[0]
    e1 = LA.eigh(H_fci)[0][0]

    H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
    d2 = H_fci.shape[0]
    
    H_fci,S_fci = project_along_singlet(H_fci,S_fci)
    d3 = H_fci.shape[0]
    
    H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
    print("after padding, matrix size ...................",H_fci.shape[0])
    d4 = H_fci.shape[0]
    e4 = LA.eigh(H_fci)[0][0]

    H_op = matrix_to_qubit_operator(H_fci)
    H_op = matrix_to_qubit_operator(H_fci)
    P = matrix_to_qubit_operator(Proj)
    J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))

    write_to_file(H_op,0,'hf_%s_h.txt'%dist)
    write_to_file(P,0,'hf_%s_p.txt'%dist)
    write_to_file(J,0,'hf_%s_php.txt'%dist)

    info.append([d1,d2,d3,d4,e1,e4])

outf = open('hf_info.txt','w')
for d1,d2,d3,d4,e1,e4 in info:
    outf.write('%d %d %d %d %.12f %.12f \n' % (d1,d2,d3,d4,e1,e4))
outf.close()

#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:20:10 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   2.100000000000 AA    0.000000000000   0.000000000000   3.968424861587 Bohr

nuclear repulsion = 2.26790233251429
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:         6.45

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpltw98g3m
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpltw98g3m
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.289967975223778  LUMO (A1) = 0.0640697934656237
Initial guess E= -99.1613582294051  |g|= 9.62664e-11
macro= 0  E= -99.1613582294051  delta_E= 0  |g|= 9.62664e-11  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-99.1613582294051  |g|= 9.62664e-11  total 2 KF 4 JK
converged SCF energy = -99.1613582294051

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpltw98g3m
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -99.392517558481  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -99.3925195051241  dE = -1.9466431e-06  S^2 = 0.0000000
               |grad[o]|=0.00313  |grad[c]|= 0.0008113127011126776  |ddm|=2.78e-05
macro iter 2 (2 JK  1 micro), CASSCF E = -99.3925195766305  dE = -7.1506392e-08  S^2 = 0.0000000
               |grad[o]|=0.000587  |grad[c]|= 5.604815484444966e-05  |ddm|=1.33e-05
macro iter 3 (1 JK  1 micro), CASSCF E = -99.3925195766305  dE = 0  S^2 = 0.0000000
               |grad[o]|=5.71e-06  |grad[c]|= 8.370707269096565e-07  |ddm|=    0
1-step CASSCF converged in 3 macro (7 JK 4 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99953114 1.99992325 1.99992325 1.29710178 0.70352057]
CASSCF energy = -99.3925195766305
CASCI E = -99.3925195766305  E(CI) = -25.729000019705  S^2 = 0.0000000
Ground state energy (orig)  -99.39251755848102
Ground state energy (pad)  -99.39251755848102
after padding, matrix size ................... 8
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/operators/gather_hf_operators.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from scipy import linalg as LA
from utils import *

def geometry(d):
    z0 = 0.1177
    z1 = 0.47116
    y0 = 0.75545
    r0 = np.sqrt(y0**2+(z0+z1)**2)
    r  = d/r0
    return "O 0.0000 0.0000 {0}; H 0.0000 {1} -{2}; H 0.0000 -{1} -{2}".format(z0*r,y0*r,z1*r)

def write_to_file(X,dX,fname):
    outf = open(fname,'w')
    for c,P in X._paulis:
        P = P.to_label()
        if(P=='I'*X.num_qubits):
           c += dX
        outf.write('%s %.12f\n' % (P,c.real))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]

info = []
for dist in dist_list:
    rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
    rho  = rho[str(dist)]['rho_scf']
    
    mol = gto.Mole()
    mol.build(atom     = [['F',(0.0000,0.0000,0.0000)],
                          ['H',(0.0000,0.0000, dist)]],
              basis    = 'sto-6g',
              symmetry = 'coov',
              spin     = 0,
              charge   = 0,
              verbose  = 4)
    mf       = scf.RHF(mol)
    mf       = scf.newton(mf)
    mf.kernel(rho)

    H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
    S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
    d1 = H_fci.shape[0]
    e1 = LA.eigh(H_fci)[0][0]

    H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
    d2 = H_fci.shape[0]
    
    H_fci,S_fci = project_along_singlet(H_fci,S_fci)
    d3 = H_fci.shape[0]
    
    H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
    print("after padding, matrix size ...................",H_fci.shape[0])
    d4 = H_fci.shape[0]
    e4 = LA.eigh(H_fci)[0][0]

    H_op = matrix_to_qubit_operator(H_fci)
    H_op = matrix_to_qubit_operator(H_fci)
    P = matrix_to_qubit_operator(Proj)
    J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))

    write_to_file(H_op,0,'hf_%s_h.txt'%dist)
    write_to_file(P,0,'hf_%s_p.txt'%dist)
    write_to_file(J,0,'hf_%s_php.txt'%dist)

    info.append([d1,d2,d3,d4,e1,e4])

outf = open('hf_info.txt','w')
for d1,d2,d3,d4,e1,e4 in info:
    outf.write('%d %d %d %d %.12f %.12f \n' % (d1,d2,d3,d4,e1,e4))
outf.close()

#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:20:10 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   2.300000000000 AA    0.000000000000   0.000000000000   4.346370086500 Bohr

nuclear repulsion = 2.07069343403478
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:         6.71

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpkytp3oez
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpkytp3oez
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.262744638798851  LUMO (A1) = 0.0376935153077713
Initial guess E= -99.1226823589012  |g|= 2.79429e-07
macro= 0  E= -99.1226823589012  delta_E= -2.84217e-14  |g|= 2.79429e-07  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-99.1226823589012  |g|= 2.79429e-07  total 2 KF 4 JK
converged SCF energy = -99.1226823589012

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpkytp3oez
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -99.3880016917654  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -99.3880027029934  dE = -1.0112281e-06  S^2 = 0.0000000
               |grad[o]|=0.00273  |grad[c]|= 0.0008104819800313257  |ddm|=1.98e-05
macro iter 2 (3 JK  1 micro), CASSCF E = -99.3880027384813  dE = -3.548783e-08  S^2 = 0.0000000
               |grad[o]|=0.0005  |grad[c]|= 4.676060771188138e-05  |ddm|=1.04e-05
macro iter 3 (1 JK  1 micro), CASSCF E = -99.3880027384813  dE = 0  S^2 = 0.0000000
               |grad[o]|=4.78e-06  |grad[c]|= 5.278760517813304e-07  |ddm|=    0
1-step CASSCF converged in 3 macro (8 JK 4 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.9997037  1.99996569 1.99996569 1.19938099 0.80098393]
CASSCF energy = -99.3880027384813
CASCI E = -99.3880027384813  E(CI) = -25.5708501641761  S^2 = 0.0000000
Ground state energy (orig)  -99.38800169176531
Ground state energy (pad)  -99.38800169176531
after padding, matrix size ................... 8
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/operators/gather_hf_operators.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from scipy import linalg as LA
from utils import *

def geometry(d):
    z0 = 0.1177
    z1 = 0.47116
    y0 = 0.75545
    r0 = np.sqrt(y0**2+(z0+z1)**2)
    r  = d/r0
    return "O 0.0000 0.0000 {0}; H 0.0000 {1} -{2}; H 0.0000 -{1} -{2}".format(z0*r,y0*r,z1*r)

def write_to_file(X,dX,fname):
    outf = open(fname,'w')
    for c,P in X._paulis:
        P = P.to_label()
        if(P=='I'*X.num_qubits):
           c += dX
        outf.write('%s %.12f\n' % (P,c.real))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]

info = []
for dist in dist_list:
    rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
    rho  = rho[str(dist)]['rho_scf']
    
    mol = gto.Mole()
    mol.build(atom     = [['F',(0.0000,0.0000,0.0000)],
                          ['H',(0.0000,0.0000, dist)]],
              basis    = 'sto-6g',
              symmetry = 'coov',
              spin     = 0,
              charge   = 0,
              verbose  = 4)
    mf       = scf.RHF(mol)
    mf       = scf.newton(mf)
    mf.kernel(rho)

    H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
    S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
    d1 = H_fci.shape[0]
    e1 = LA.eigh(H_fci)[0][0]

    H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
    d2 = H_fci.shape[0]
    
    H_fci,S_fci = project_along_singlet(H_fci,S_fci)
    d3 = H_fci.shape[0]
    
    H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
    print("after padding, matrix size ...................",H_fci.shape[0])
    d4 = H_fci.shape[0]
    e4 = LA.eigh(H_fci)[0][0]

    H_op = matrix_to_qubit_operator(H_fci)
    H_op = matrix_to_qubit_operator(H_fci)
    P = matrix_to_qubit_operator(Proj)
    J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))

    write_to_file(H_op,0,'hf_%s_h.txt'%dist)
    write_to_file(P,0,'hf_%s_p.txt'%dist)
    write_to_file(J,0,'hf_%s_php.txt'%dist)

    info.append([d1,d2,d3,d4,e1,e4])

outf = open('hf_info.txt','w')
for d1,d2,d3,d4,e1,e4 in info:
    outf.write('%d %d %d %d %.12f %.12f \n' % (d1,d2,d3,d4,e1,e4))
outf.close()

#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:20:11 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   2.500000000000 AA    0.000000000000   0.000000000000   4.724315311413 Bohr

nuclear repulsion = 1.905037959312
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:         6.98

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpk2gxdwac
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpk2gxdwac
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.24148743122029  LUMO (A1) = 0.0182022590922797
Initial guess E= -99.0932404499966  |g|= 2.18281e-13
macro= 0  E= -99.0932404499966  delta_E= 0  |g|= 2.18293e-13  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-99.0932404499966  |g|= 2.18293e-13  total 2 KF 4 JK
converged SCF energy = -99.0932404499966

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpk2gxdwac
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -99.3859206843925  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -99.3859212036249  dE = -5.1923239e-07  S^2 = 0.0000000
               |grad[o]|=0.00228  |grad[c]|= 0.0008100213021640194  |ddm|=1.38e-05
macro iter 2 (2 JK  1 micro), CASSCF E = -99.3859212213126  dE = -1.7687753e-08  S^2 = 0.0000000
               |grad[o]|=0.000412  |grad[c]|= 4.329164234037665e-05  |ddm|=8.29e-06
macro iter 3 (1 JK  1 micro), CASSCF E = -99.3859212213126  dE = 0  S^2 = 0.0000000
               |grad[o]|=3.7e-06  |grad[c]|= 3.3717238861058256e-07  |ddm|=    0
1-step CASSCF converged in 3 macro (7 JK 4 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99981022 1.99998526 1.99998526 1.13122191 0.86899735]
CASSCF energy = -99.3859212213126
CASCI E = -99.3859212213126  E(CI) = -25.4397415697712  S^2 = 0.0000000
Ground state energy (orig)  -99.385920684444
Ground state energy (pad)  -99.385920684444
after padding, matrix size ................... 8
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/operators/gather_hf_operators.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from scipy import linalg as LA
from utils import *

def geometry(d):
    z0 = 0.1177
    z1 = 0.47116
    y0 = 0.75545
    r0 = np.sqrt(y0**2+(z0+z1)**2)
    r  = d/r0
    return "O 0.0000 0.0000 {0}; H 0.0000 {1} -{2}; H 0.0000 -{1} -{2}".format(z0*r,y0*r,z1*r)

def write_to_file(X,dX,fname):
    outf = open(fname,'w')
    for c,P in X._paulis:
        P = P.to_label()
        if(P=='I'*X.num_qubits):
           c += dX
        outf.write('%s %.12f\n' % (P,c.real))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]

info = []
for dist in dist_list:
    rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
    rho  = rho[str(dist)]['rho_scf']
    
    mol = gto.Mole()
    mol.build(atom     = [['F',(0.0000,0.0000,0.0000)],
                          ['H',(0.0000,0.0000, dist)]],
              basis    = 'sto-6g',
              symmetry = 'coov',
              spin     = 0,
              charge   = 0,
              verbose  = 4)
    mf       = scf.RHF(mol)
    mf       = scf.newton(mf)
    mf.kernel(rho)

    H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
    S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
    d1 = H_fci.shape[0]
    e1 = LA.eigh(H_fci)[0][0]

    H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
    d2 = H_fci.shape[0]
    
    H_fci,S_fci = project_along_singlet(H_fci,S_fci)
    d3 = H_fci.shape[0]
    
    H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
    print("after padding, matrix size ...................",H_fci.shape[0])
    d4 = H_fci.shape[0]
    e4 = LA.eigh(H_fci)[0][0]

    H_op = matrix_to_qubit_operator(H_fci)
    H_op = matrix_to_qubit_operator(H_fci)
    P = matrix_to_qubit_operator(Proj)
    J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))

    write_to_file(H_op,0,'hf_%s_h.txt'%dist)
    write_to_file(P,0,'hf_%s_p.txt'%dist)
    write_to_file(J,0,'hf_%s_php.txt'%dist)

    info.append([d1,d2,d3,d4,e1,e4])

outf = open('hf_info.txt','w')
for d1,d2,d3,d4,e1,e4 in info:
    outf.write('%d %d %d %d %.12f %.12f \n' % (d1,d2,d3,d4,e1,e4))
outf.close()

#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:20:11 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   2.700000000000 AA    0.000000000000   0.000000000000   5.102260536326 Bohr

nuclear repulsion = 1.7639240364
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:         7.24

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmps9lmrui0
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmps9lmrui0
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.224985116259024  LUMO (A1) = 0.00354474942025124
Initial guess E= -99.0710816036006  |g|= 4.26535e-07
macro= 0  E= -99.0710816036006  delta_E= 2.84217e-14  |g|= 4.26535e-07  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-99.0710816036006  |g|= 4.26535e-07  total 2 KF 4 JK
converged SCF energy = -99.0710816036006

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmps9lmrui0
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -99.3849927177433  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -99.3849929880873  dE = -2.7034403e-07  S^2 = 0.0000000
               |grad[o]|=0.00186  |grad[c]|= 0.0008097734115262723  |ddm|=8.73e-06
macro iter 2 (2 JK  1 micro), CASSCF E = -99.3849929970954  dE = -9.0080619e-09  S^2 = 0.0000000
               |grad[o]|=0.000333  |grad[c]|= 4.1261662404538e-05  |ddm|=6.45e-06
macro iter 3 (1 JK  1 micro), CASSCF E = -99.3849929970954  dE = 0  S^2 = 0.0000000
               |grad[o]|=2.62e-06  |grad[c]|= 2.1585790179341162e-07  |ddm|=    0
1-step CASSCF converged in 3 macro (7 JK 4 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99987501 1.99999382 1.99999382 1.08533889 0.91479846]
CASSCF energy = -99.3849929970954
CASCI E = -99.3849929970954  E(CI) = -25.3289344041544  S^2 = 0.0000000
Ground state energy (orig)  -99.38499271774695
Ground state energy (pad)  -99.38499271774695
after padding, matrix size ................... 8
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/operators/gather_hf_operators.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from scipy import linalg as LA
from utils import *

def geometry(d):
    z0 = 0.1177
    z1 = 0.47116
    y0 = 0.75545
    r0 = np.sqrt(y0**2+(z0+z1)**2)
    r  = d/r0
    return "O 0.0000 0.0000 {0}; H 0.0000 {1} -{2}; H 0.0000 -{1} -{2}".format(z0*r,y0*r,z1*r)

def write_to_file(X,dX,fname):
    outf = open(fname,'w')
    for c,P in X._paulis:
        P = P.to_label()
        if(P=='I'*X.num_qubits):
           c += dX
        outf.write('%s %.12f\n' % (P,c.real))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]

info = []
for dist in dist_list:
    rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
    rho  = rho[str(dist)]['rho_scf']
    
    mol = gto.Mole()
    mol.build(atom     = [['F',(0.0000,0.0000,0.0000)],
                          ['H',(0.0000,0.0000, dist)]],
              basis    = 'sto-6g',
              symmetry = 'coov',
              spin     = 0,
              charge   = 0,
              verbose  = 4)
    mf       = scf.RHF(mol)
    mf       = scf.newton(mf)
    mf.kernel(rho)

    H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
    S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
    d1 = H_fci.shape[0]
    e1 = LA.eigh(H_fci)[0][0]

    H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
    d2 = H_fci.shape[0]
    
    H_fci,S_fci = project_along_singlet(H_fci,S_fci)
    d3 = H_fci.shape[0]
    
    H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
    print("after padding, matrix size ...................",H_fci.shape[0])
    d4 = H_fci.shape[0]
    e4 = LA.eigh(H_fci)[0][0]

    H_op = matrix_to_qubit_operator(H_fci)
    H_op = matrix_to_qubit_operator(H_fci)
    P = matrix_to_qubit_operator(Proj)
    J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))

    write_to_file(H_op,0,'hf_%s_h.txt'%dist)
    write_to_file(P,0,'hf_%s_p.txt'%dist)
    write_to_file(J,0,'hf_%s_php.txt'%dist)

    info.append([d1,d2,d3,d4,e1,e4])

outf = open('hf_info.txt','w')
for d1,d2,d3,d4,e1,e4 in info:
    outf.write('%d %d %d %d %.12f %.12f \n' % (d1,d2,d3,d4,e1,e4))
outf.close()

#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:20:11 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   2.900000000000 AA    0.000000000000   0.000000000000   5.480205761239 Bohr

nuclear repulsion = 1.64227410285517
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:         7.51

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpszkq376p
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpszkq376p
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.212147344140101  LUMO (A1) = -0.00770312088091207
Initial guess E= -99.0544327404167  |g|= 1.00378e-13
macro= 0  E= -99.0544327404167  delta_E= 0  |g|= 1.00368e-13  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-99.0544327404167  |g|= 1.00368e-13  total 2 KF 4 JK
converged SCF energy = -99.0544327404167

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpszkq376p
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -99.3845887579858  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -99.3845889040257  dE = -1.4603995e-07  S^2 = 0.0000000
               |grad[o]|=0.00152  |grad[c]|= 0.0008096408056429037  |ddm|=7.77e-06
macro iter 2 (2 JK  1 micro), CASSCF E = -99.3845889088118  dE = -4.7860595e-09  S^2 = 0.0000000
               |grad[o]|=0.000269  |grad[c]|= 4.029347579652764e-05  |ddm|=4.98e-06
1-step CASSCF converged in 2 macro (6 JK 3 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.9999148  1.99999745 1.99999745 1.05506894 0.94502136]
CASSCF energy = -99.3845889088118
CASCI E = -99.3845889088118  E(CI) = -25.2338536124544  S^2 = 0.0000000
Ground state energy (orig)  -99.38458875799078
Ground state energy (pad)  -99.38458875799078
after padding, matrix size ................... 8
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/operators/gather_hf_operators.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from scipy import linalg as LA
from utils import *

def geometry(d):
    z0 = 0.1177
    z1 = 0.47116
    y0 = 0.75545
    r0 = np.sqrt(y0**2+(z0+z1)**2)
    r  = d/r0
    return "O 0.0000 0.0000 {0}; H 0.0000 {1} -{2}; H 0.0000 -{1} -{2}".format(z0*r,y0*r,z1*r)

def write_to_file(X,dX,fname):
    outf = open(fname,'w')
    for c,P in X._paulis:
        P = P.to_label()
        if(P=='I'*X.num_qubits):
           c += dX
        outf.write('%s %.12f\n' % (P,c.real))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]

info = []
for dist in dist_list:
    rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
    rho  = rho[str(dist)]['rho_scf']
    
    mol = gto.Mole()
    mol.build(atom     = [['F',(0.0000,0.0000,0.0000)],
                          ['H',(0.0000,0.0000, dist)]],
              basis    = 'sto-6g',
              symmetry = 'coov',
              spin     = 0,
              charge   = 0,
              verbose  = 4)
    mf       = scf.RHF(mol)
    mf       = scf.newton(mf)
    mf.kernel(rho)

    H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
    S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
    d1 = H_fci.shape[0]
    e1 = LA.eigh(H_fci)[0][0]

    H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
    d2 = H_fci.shape[0]
    
    H_fci,S_fci = project_along_singlet(H_fci,S_fci)
    d3 = H_fci.shape[0]
    
    H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
    print("after padding, matrix size ...................",H_fci.shape[0])
    d4 = H_fci.shape[0]
    e4 = LA.eigh(H_fci)[0][0]

    H_op = matrix_to_qubit_operator(H_fci)
    H_op = matrix_to_qubit_operator(H_fci)
    P = matrix_to_qubit_operator(Proj)
    J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))

    write_to_file(H_op,0,'hf_%s_h.txt'%dist)
    write_to_file(P,0,'hf_%s_p.txt'%dist)
    write_to_file(J,0,'hf_%s_php.txt'%dist)

    info.append([d1,d2,d3,d4,e1,e4])

outf = open('hf_info.txt','w')
for d1,d2,d3,d4,e1,e4 in info:
    outf.write('%d %d %d %d %.12f %.12f \n' % (d1,d2,d3,d4,e1,e4))
outf.close()

#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:20:11 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   3.100000000000 AA    0.000000000000   0.000000000000   5.858150986152 Bohr

nuclear repulsion = 1.53632093492903
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:         7.76

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp06o2zpqw
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp06o2zpqw
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.202070163395726  LUMO (A1) = -0.0165281195458867
Initial guess E= -99.0418397777126  |g|= 1.6188e-07
macro= 0  E= -99.0418397777126  delta_E= 0  |g|= 1.6188e-07  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-99.0418397777126  |g|= 1.6188e-07  total 2 KF 4 JK
converged SCF energy = -99.0418397777126

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp06o2zpqw
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -99.3844162570877  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -99.3844163404757  dE = -8.338796e-08  S^2 = 0.0000000
               |grad[o]|=0.00125  |grad[c]|= 0.0008095687175108673  |ddm|=8.74e-06
macro iter 2 (3 JK  1 micro), CASSCF E = -99.3844163431757  dE = -2.6999771e-09  S^2 = 0.0000000
               |grad[o]|=0.00022  |grad[c]|= 4.0365074496443164e-05  |ddm|=3.88e-06
1-step CASSCF converged in 2 macro (7 JK 3 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99993984 1.99999896 1.99999896 1.03535639 0.96470585]
CASSCF energy = -99.3844163431757
CASCI E = -99.3844163431757  E(CI) = -25.1512986825357  S^2 = 0.0000000
Ground state energy (orig)  -99.38441625710898
Ground state energy (pad)  -99.38441625710898
after padding, matrix size ................... 8
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/operators/gather_hf_operators.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from scipy import linalg as LA
from utils import *

def geometry(d):
    z0 = 0.1177
    z1 = 0.47116
    y0 = 0.75545
    r0 = np.sqrt(y0**2+(z0+z1)**2)
    r  = d/r0
    return "O 0.0000 0.0000 {0}; H 0.0000 {1} -{2}; H 0.0000 -{1} -{2}".format(z0*r,y0*r,z1*r)

def write_to_file(X,dX,fname):
    outf = open(fname,'w')
    for c,P in X._paulis:
        P = P.to_label()
        if(P=='I'*X.num_qubits):
           c += dX
        outf.write('%s %.12f\n' % (P,c.real))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]

info = []
for dist in dist_list:
    rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
    rho  = rho[str(dist)]['rho_scf']
    
    mol = gto.Mole()
    mol.build(atom     = [['F',(0.0000,0.0000,0.0000)],
                          ['H',(0.0000,0.0000, dist)]],
              basis    = 'sto-6g',
              symmetry = 'coov',
              spin     = 0,
              charge   = 0,
              verbose  = 4)
    mf       = scf.RHF(mol)
    mf       = scf.newton(mf)
    mf.kernel(rho)

    H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
    S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
    d1 = H_fci.shape[0]
    e1 = LA.eigh(H_fci)[0][0]

    H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
    d2 = H_fci.shape[0]
    
    H_fci,S_fci = project_along_singlet(H_fci,S_fci)
    d3 = H_fci.shape[0]
    
    H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
    print("after padding, matrix size ...................",H_fci.shape[0])
    d4 = H_fci.shape[0]
    e4 = LA.eigh(H_fci)[0][0]

    H_op = matrix_to_qubit_operator(H_fci)
    H_op = matrix_to_qubit_operator(H_fci)
    P = matrix_to_qubit_operator(Proj)
    J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))

    write_to_file(H_op,0,'hf_%s_h.txt'%dist)
    write_to_file(P,0,'hf_%s_p.txt'%dist)
    write_to_file(J,0,'hf_%s_php.txt'%dist)

    info.append([d1,d2,d3,d4,e1,e4])

outf = open('hf_info.txt','w')
for d1,d2,d3,d4,e1,e4 in info:
    outf.write('%d %d %d %d %.12f %.12f \n' % (d1,d2,d3,d4,e1,e4))
outf.close()

#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:20:12 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   3.300000000000 AA    0.000000000000   0.000000000000   6.236096211065 Bohr

nuclear repulsion = 1.44321057523636
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:         8.01

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp7iwoyxa1
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp7iwoyxa1
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.194043361807192  LUMO (A1) = -0.0236156021552729
Initial guess E= -99.0321791751506  |g|= 5.09142e-07
macro= 0  E= -99.0321791751506  delta_E= -4.26326e-14  |g|= 5.09142e-07  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-99.0321791751506  |g|= 5.09142e-07  total 2 KF 4 JK
converged SCF energy = -99.0321791751506

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp7iwoyxa1
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -99.3843436732085  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -99.384343724111  dE = -5.0902514e-08  S^2 = 0.0000000
               |grad[o]|=0.00104  |grad[c]|= 0.000809528347738442  |ddm|=9.28e-06
macro iter 2 (3 JK  1 micro), CASSCF E = -99.3843437257381  dE = -1.6271002e-09  S^2 = 0.0000000
               |grad[o]|=0.000182  |grad[c]|= 4.07097920489111e-05  |ddm|=3.07e-06
1-step CASSCF converged in 2 macro (7 JK 3 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99995611 1.99999958 1.99999958 1.02263032 0.97741443]
CASSCF energy = -99.3843437257381
CASCI E = -99.3843437257381  E(CI) = -25.0788503577368  S^2 = 0.0000000
Ground state energy (orig)  -99.3843436732421
Ground state energy (pad)  -99.3843436732421
after padding, matrix size ................... 8
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/operators/gather_hf_operators.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from scipy import linalg as LA
from utils import *

def geometry(d):
    z0 = 0.1177
    z1 = 0.47116
    y0 = 0.75545
    r0 = np.sqrt(y0**2+(z0+z1)**2)
    r  = d/r0
    return "O 0.0000 0.0000 {0}; H 0.0000 {1} -{2}; H 0.0000 -{1} -{2}".format(z0*r,y0*r,z1*r)

def write_to_file(X,dX,fname):
    outf = open(fname,'w')
    for c,P in X._paulis:
        P = P.to_label()
        if(P=='I'*X.num_qubits):
           c += dX
        outf.write('%s %.12f\n' % (P,c.real))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]

info = []
for dist in dist_list:
    rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
    rho  = rho[str(dist)]['rho_scf']
    
    mol = gto.Mole()
    mol.build(atom     = [['F',(0.0000,0.0000,0.0000)],
                          ['H',(0.0000,0.0000, dist)]],
              basis    = 'sto-6g',
              symmetry = 'coov',
              spin     = 0,
              charge   = 0,
              verbose  = 4)
    mf       = scf.RHF(mol)
    mf       = scf.newton(mf)
    mf.kernel(rho)

    H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
    S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
    d1 = H_fci.shape[0]
    e1 = LA.eigh(H_fci)[0][0]

    H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
    d2 = H_fci.shape[0]
    
    H_fci,S_fci = project_along_singlet(H_fci,S_fci)
    d3 = H_fci.shape[0]
    
    H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
    print("after padding, matrix size ...................",H_fci.shape[0])
    d4 = H_fci.shape[0]
    e4 = LA.eigh(H_fci)[0][0]

    H_op = matrix_to_qubit_operator(H_fci)
    H_op = matrix_to_qubit_operator(H_fci)
    P = matrix_to_qubit_operator(Proj)
    J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))

    write_to_file(H_op,0,'hf_%s_h.txt'%dist)
    write_to_file(P,0,'hf_%s_p.txt'%dist)
    write_to_file(J,0,'hf_%s_php.txt'%dist)

    info.append([d1,d2,d3,d4,e1,e4])

outf = open('hf_info.txt','w')
for d1,d2,d3,d4,e1,e4 in info:
    outf.write('%d %d %d %d %.12f %.12f \n' % (d1,d2,d3,d4,e1,e4))
outf.close()

#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:20:12 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   3.500000000000 AA    0.000000000000   0.000000000000   6.614041435978 Bohr

nuclear repulsion = 1.36074139950857
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:         8.26

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpo63m6cgr
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpo63m6cgr
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.1875305900461  LUMO (A1) = -0.0294422171042515
Initial guess E= -99.0246183618545  |g|= 1.14122e-06
macro= 0  E= -99.0246183618554  delta_E= -9.09495e-13  |g|= 1.14122e-06  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-99.0246183618554  |g|= 1.14122e-06  total 2 KF 4 JK
converged SCF energy = -99.0246183618554

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpo63m6cgr
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -99.3843134243156  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -99.384313457599  dE = -3.328347e-08  S^2 = 0.0000000
               |grad[o]|=0.000881  |grad[c]|= 0.0008095048455814042  |ddm|=9.37e-06
macro iter 2 (3 JK  1 micro), CASSCF E = -99.3843134586369  dE = -1.0378756e-09  S^2 = 0.0000000
               |grad[o]|=0.000152  |grad[c]|= 4.11517286936402e-05  |ddm|=2.46e-06
1-step CASSCF converged in 2 macro (7 JK 3 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99996703 1.99999983 1.99999983 1.01445694 0.98557638]
CASSCF energy = -99.3843134586369
CASCI E = -99.3843134586369  E(CI) = -25.0147263322809  S^2 = 0.0000000
Ground state energy (orig)  -99.3843134243554
Ground state energy (pad)  -99.3843134243554
after padding, matrix size ................... 8
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/operators/gather_hf_operators.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from scipy import linalg as LA
from utils import *

def geometry(d):
    z0 = 0.1177
    z1 = 0.47116
    y0 = 0.75545
    r0 = np.sqrt(y0**2+(z0+z1)**2)
    r  = d/r0
    return "O 0.0000 0.0000 {0}; H 0.0000 {1} -{2}; H 0.0000 -{1} -{2}".format(z0*r,y0*r,z1*r)

def write_to_file(X,dX,fname):
    outf = open(fname,'w')
    for c,P in X._paulis:
        P = P.to_label()
        if(P=='I'*X.num_qubits):
           c += dX
        outf.write('%s %.12f\n' % (P,c.real))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]

info = []
for dist in dist_list:
    rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
    rho  = rho[str(dist)]['rho_scf']
    
    mol = gto.Mole()
    mol.build(atom     = [['F',(0.0000,0.0000,0.0000)],
                          ['H',(0.0000,0.0000, dist)]],
              basis    = 'sto-6g',
              symmetry = 'coov',
              spin     = 0,
              charge   = 0,
              verbose  = 4)
    mf       = scf.RHF(mol)
    mf       = scf.newton(mf)
    mf.kernel(rho)

    H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
    S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
    d1 = H_fci.shape[0]
    e1 = LA.eigh(H_fci)[0][0]

    H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
    d2 = H_fci.shape[0]
    
    H_fci,S_fci = project_along_singlet(H_fci,S_fci)
    d3 = H_fci.shape[0]
    
    H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
    print("after padding, matrix size ...................",H_fci.shape[0])
    d4 = H_fci.shape[0]
    e4 = LA.eigh(H_fci)[0][0]

    H_op = matrix_to_qubit_operator(H_fci)
    H_op = matrix_to_qubit_operator(H_fci)
    P = matrix_to_qubit_operator(Proj)
    J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))

    write_to_file(H_op,0,'hf_%s_h.txt'%dist)
    write_to_file(P,0,'hf_%s_p.txt'%dist)
    write_to_file(J,0,'hf_%s_php.txt'%dist)

    info.append([d1,d2,d3,d4,e1,e4])

outf = open('hf_info.txt','w')
for d1,d2,d3,d4,e1,e4 in info:
    outf.write('%d %d %d %d %.12f %.12f \n' % (d1,d2,d3,d4,e1,e4))
outf.close()

#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:20:12 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   3.700000000000 AA    0.000000000000   0.000000000000   6.991986660891 Bohr

nuclear repulsion = 1.28718781034595
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:         8.51

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmplp3cicgw
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmplp3cicgw
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.182138742472354  LUMO (A1) = -0.0343391486455454
Initial guess E= -99.0185601194037  |g|= 1.19475e-11
macro= 0  E= -99.0185601194038  delta_E= -2.84217e-14  |g|= 1.19475e-11  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-99.0185601194038  |g|= 1.19475e-11  total 2 KF 4 JK
converged SCF energy = -99.0185601194038

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmplp3cicgw
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -99.3843008777976  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -99.3843009009819  dE = -2.3184342e-08  S^2 = 0.0000000
               |grad[o]|=0.000757  |grad[c]|= 0.000809490582170683  |ddm|=9.21e-06
macro iter 2 (2 JK  1 micro), CASSCF E = -99.3843009016665  dE = -6.8460793e-10  S^2 = 0.0000000
               |grad[o]|=0.000127  |grad[c]|= 3.4949067604909586e-05  |ddm|=1.99e-06
1-step CASSCF converged in 2 macro (6 JK 3 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99997461 1.99999993 1.99999993 1.00921814 0.99080739]
CASSCF energy = -99.3843009016665
CASCI E = -99.3843009016665  E(CI) = -24.9568606497574  S^2 = 0.0000000
Ground state energy (orig)  -99.38430087783937
Ground state energy (pad)  -99.38430087783937
after padding, matrix size ................... 8
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/operators/gather_hf_operators.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from scipy import linalg as LA
from utils import *

def geometry(d):
    z0 = 0.1177
    z1 = 0.47116
    y0 = 0.75545
    r0 = np.sqrt(y0**2+(z0+z1)**2)
    r  = d/r0
    return "O 0.0000 0.0000 {0}; H 0.0000 {1} -{2}; H 0.0000 -{1} -{2}".format(z0*r,y0*r,z1*r)

def write_to_file(X,dX,fname):
    outf = open(fname,'w')
    for c,P in X._paulis:
        P = P.to_label()
        if(P=='I'*X.num_qubits):
           c += dX
        outf.write('%s %.12f\n' % (P,c.real))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]

info = []
for dist in dist_list:
    rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
    rho  = rho[str(dist)]['rho_scf']
    
    mol = gto.Mole()
    mol.build(atom     = [['F',(0.0000,0.0000,0.0000)],
                          ['H',(0.0000,0.0000, dist)]],
              basis    = 'sto-6g',
              symmetry = 'coov',
              spin     = 0,
              charge   = 0,
              verbose  = 4)
    mf       = scf.RHF(mol)
    mf       = scf.newton(mf)
    mf.kernel(rho)

    H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
    S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
    d1 = H_fci.shape[0]
    e1 = LA.eigh(H_fci)[0][0]

    H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
    d2 = H_fci.shape[0]
    
    H_fci,S_fci = project_along_singlet(H_fci,S_fci)
    d3 = H_fci.shape[0]
    
    H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
    print("after padding, matrix size ...................",H_fci.shape[0])
    d4 = H_fci.shape[0]
    e4 = LA.eigh(H_fci)[0][0]

    H_op = matrix_to_qubit_operator(H_fci)
    H_op = matrix_to_qubit_operator(H_fci)
    P = matrix_to_qubit_operator(Proj)
    J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))

    write_to_file(H_op,0,'hf_%s_h.txt'%dist)
    write_to_file(P,0,'hf_%s_p.txt'%dist)
    write_to_file(J,0,'hf_%s_php.txt'%dist)

    info.append([d1,d2,d3,d4,e1,e4])

outf = open('hf_info.txt','w')
for d1,d2,d3,d4,e1,e4 in info:
    outf.write('%d %d %d %d %.12f %.12f \n' % (d1,d2,d3,d4,e1,e4))
outf.close()

#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:20:12 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   3.900000000000 AA    0.000000000000   0.000000000000   7.369931885804 Bohr

nuclear repulsion = 1.22117817904615
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:         8.77

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpyg1yuf9f
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpyg1yuf9f
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.177586145623986  LUMO (A1) = -0.0385366012948476
Initial guess E= -99.0135862783171  |g|= 1.60044e-11
macro= 0  E= -99.0135862783172  delta_E= -2.84217e-14  |g|= 1.60043e-11  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-99.0135862783172  |g|= 1.60043e-11  total 2 KF 4 JK
converged SCF energy = -99.0135862783172

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpyg1yuf9f
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -99.3842956828733  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -99.3842956999102  dE = -1.7036953e-08  S^2 = 0.0000000
               |grad[o]|=0.00066  |grad[c]|= 0.0008094815827986739  |ddm|=8.89e-06
macro iter 2 (2 JK  1 micro), CASSCF E = -99.3842957003598  dE = -4.4961723e-10  S^2 = 0.0000000
               |grad[o]|=0.000105  |grad[c]|= 3.05704988814974e-05  |ddm|=1.55e-06
1-step CASSCF converged in 2 macro (6 JK 3 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99998003 1.99999997 1.99999997 1.00585988 0.99416014]
CASSCF energy = -99.3842957003598
CASCI E = -99.3842957003598  E(CI) = -24.9050339607057  S^2 = 0.0000000
Ground state energy (orig)  -99.38429568291431
Ground state energy (pad)  -99.38429568291431
after padding, matrix size ................... 8
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/operators/gather_hf_operators.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from scipy import linalg as LA
from utils import *

def geometry(d):
    z0 = 0.1177
    z1 = 0.47116
    y0 = 0.75545
    r0 = np.sqrt(y0**2+(z0+z1)**2)
    r  = d/r0
    return "O 0.0000 0.0000 {0}; H 0.0000 {1} -{2}; H 0.0000 -{1} -{2}".format(z0*r,y0*r,z1*r)

def write_to_file(X,dX,fname):
    outf = open(fname,'w')
    for c,P in X._paulis:
        P = P.to_label()
        if(P=='I'*X.num_qubits):
           c += dX
        outf.write('%s %.12f\n' % (P,c.real))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]

info = []
for dist in dist_list:
    rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
    rho  = rho[str(dist)]['rho_scf']
    
    mol = gto.Mole()
    mol.build(atom     = [['F',(0.0000,0.0000,0.0000)],
                          ['H',(0.0000,0.0000, dist)]],
              basis    = 'sto-6g',
              symmetry = 'coov',
              spin     = 0,
              charge   = 0,
              verbose  = 4)
    mf       = scf.RHF(mol)
    mf       = scf.newton(mf)
    mf.kernel(rho)

    H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
    S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
    d1 = H_fci.shape[0]
    e1 = LA.eigh(H_fci)[0][0]

    H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
    d2 = H_fci.shape[0]
    
    H_fci,S_fci = project_along_singlet(H_fci,S_fci)
    d3 = H_fci.shape[0]
    
    H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
    print("after padding, matrix size ...................",H_fci.shape[0])
    d4 = H_fci.shape[0]
    e4 = LA.eigh(H_fci)[0][0]

    H_op = matrix_to_qubit_operator(H_fci)
    H_op = matrix_to_qubit_operator(H_fci)
    P = matrix_to_qubit_operator(Proj)
    J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))

    write_to_file(H_op,0,'hf_%s_h.txt'%dist)
    write_to_file(P,0,'hf_%s_p.txt'%dist)
    write_to_file(J,0,'hf_%s_php.txt'%dist)

    info.append([d1,d2,d3,d4,e1,e4])

outf = open('hf_info.txt','w')
for d1,d2,d3,d4,e1,e4 in info:
    outf.write('%d %d %d %d %.12f %.12f \n' % (d1,d2,d3,d4,e1,e4))
outf.close()

#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:20:13 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   4.100000000000 AA    0.000000000000   0.000000000000   7.747877110717 Bohr

nuclear repulsion = 1.16160851177561
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:         9.02

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpy_dhekwe
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpy_dhekwe
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.173672731751752  LUMO (A1) = -0.0421952265705259
Initial guess E= -99.0094080380603  |g|= 1.74373e-11
macro= 0  E= -99.0094080380603  delta_E= -1.42109e-14  |g|= 1.74373e-11  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-99.0094080380603  |g|= 1.74373e-11  total 2 KF 4 JK
converged SCF energy = -99.0094080380603

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpy_dhekwe
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -99.384293536064  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -99.3842935491384  dE = -1.3074413e-08  S^2 = 0.0000000
               |grad[o]|=0.000583  |grad[c]|= 0.0008094757086514381  |ddm|=8.43e-06
macro iter 2 (2 JK  1 micro), CASSCF E = -99.3842935494118  dE = -2.7338842e-10  S^2 = 0.0000000
               |grad[o]|=8.3e-05  |grad[c]|= 2.3315346036895437e-05  |ddm|=1.12e-06
1-step CASSCF converged in 2 macro (6 JK 3 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99998402 1.99999999 1.99999999 1.0037059  0.9963101 ]
CASSCF energy = -99.3842935494118
CASCI E = -99.3842935494118  E(CI) = -24.8578383902893  S^2 = 0.0000000
Ground state energy (orig)  -99.3842935361028
Ground state energy (pad)  -99.3842935361028
after padding, matrix size ................... 8
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/operators/gather_hf_operators.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from scipy import linalg as LA
from utils import *

def geometry(d):
    z0 = 0.1177
    z1 = 0.47116
    y0 = 0.75545
    r0 = np.sqrt(y0**2+(z0+z1)**2)
    r  = d/r0
    return "O 0.0000 0.0000 {0}; H 0.0000 {1} -{2}; H 0.0000 -{1} -{2}".format(z0*r,y0*r,z1*r)

def write_to_file(X,dX,fname):
    outf = open(fname,'w')
    for c,P in X._paulis:
        P = P.to_label()
        if(P=='I'*X.num_qubits):
           c += dX
        outf.write('%s %.12f\n' % (P,c.real))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]

info = []
for dist in dist_list:
    rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
    rho  = rho[str(dist)]['rho_scf']
    
    mol = gto.Mole()
    mol.build(atom     = [['F',(0.0000,0.0000,0.0000)],
                          ['H',(0.0000,0.0000, dist)]],
              basis    = 'sto-6g',
              symmetry = 'coov',
              spin     = 0,
              charge   = 0,
              verbose  = 4)
    mf       = scf.RHF(mol)
    mf       = scf.newton(mf)
    mf.kernel(rho)

    H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
    S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
    d1 = H_fci.shape[0]
    e1 = LA.eigh(H_fci)[0][0]

    H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
    d2 = H_fci.shape[0]
    
    H_fci,S_fci = project_along_singlet(H_fci,S_fci)
    d3 = H_fci.shape[0]
    
    H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
    print("after padding, matrix size ...................",H_fci.shape[0])
    d4 = H_fci.shape[0]
    e4 = LA.eigh(H_fci)[0][0]

    H_op = matrix_to_qubit_operator(H_fci)
    H_op = matrix_to_qubit_operator(H_fci)
    P = matrix_to_qubit_operator(Proj)
    J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))

    write_to_file(H_op,0,'hf_%s_h.txt'%dist)
    write_to_file(P,0,'hf_%s_p.txt'%dist)
    write_to_file(J,0,'hf_%s_php.txt'%dist)

    info.append([d1,d2,d3,d4,e1,e4])

outf = open('hf_info.txt','w')
for d1,d2,d3,d4,e1,e4 in info:
    outf.write('%d %d %d %d %.12f %.12f \n' % (d1,d2,d3,d4,e1,e4))
outf.close()

#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:20:13 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   4.300000000000 AA    0.000000000000   0.000000000000   8.125822335630 Bohr

nuclear repulsion = 1.10758020890233
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:         9.28

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp5kseh7ip
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp5kseh7ip
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.170256252773826  LUMO (A1) = -0.0454285623802469
Initial guess E= -99.0058262661332  |g|= 1.63161e-11
macro= 0  E= -99.0058262661332  delta_E= -1.42109e-14  |g|= 1.6316e-11  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-99.0058262661332  |g|= 1.6316e-11  total 2 KF 4 JK
converged SCF energy = -99.0058262661332

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmp5kseh7ip
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -99.3842926537504  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (4 JK  2 micro), CASSCF E = -99.3842926641387  dE = -1.0388291e-08  S^2 = 0.0000000
               |grad[o]|=0.00052  |grad[c]|= 0.0008094717473018889  |ddm|=7.8e-06
macro iter 2 (2 JK  1 micro), CASSCF E = -99.3842926642659  dE = -1.271161e-10  S^2 = 0.0000000
               |grad[o]|=5.69e-05  |grad[c]|= 1.2697473780674043e-05  |ddm|=6.1e-07
1-step CASSCF converged in 2 macro (6 JK 3 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99998702 2.         2.         1.00232555 0.99768744]
CASSCF energy = -99.3842926642659
CASCI E = -99.3842926642659  E(CI) = -24.8143236623991  S^2 = 0.0000000
Ground state energy (orig)  -99.384292653786
Ground state energy (pad)  -99.384292653786
after padding, matrix size ................... 8
#INFO: **** input file is /Users/mario/Documents/GitHub/VATech/quantum_database/first_quantization/pad/operators/gather_hf_operators.py ****
from pyscf import gto,scf
import numpy as np
import sys
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/first_quantization_pad/src/')
from subroutines import get_hamiltonian_matrix,get_spin_square_matrix,project_along_irrep,project_along_singlet,pad_matrix,trim
from quantum import matrix_to_qubit_operator,make_cascade_ansatz,do_VQE

import numpy as np
sys.path.append('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/subroutines/')
from scipy import linalg as LA
from utils import *

def geometry(d):
    z0 = 0.1177
    z1 = 0.47116
    y0 = 0.75545
    r0 = np.sqrt(y0**2+(z0+z1)**2)
    r  = d/r0
    return "O 0.0000 0.0000 {0}; H 0.0000 {1} -{2}; H 0.0000 -{1} -{2}".format(z0*r,y0*r,z1*r)

def write_to_file(X,dX,fname):
    outf = open(fname,'w')
    for c,P in X._paulis:
        P = P.to_label()
        if(P=='I'*X.num_qubits):
           c += dX
        outf.write('%s %.12f\n' % (P,c.real))
    outf.close()

dist_list = [0.5,0.7,0.9,1.1,1.3,1.5,1.7,1.9,2.1,2.3,2.5,2.7,2.9,3.1,3.3,3.5,3.7,3.9,4.1,4.3,4.5]

info = []
for dist in dist_list:
    rho  = np.load('/Users/mario/Documents/GitHub/QITE/qite_es/scf_calculations/SCF_FCI/hf/res_fourth_pass.npy',allow_pickle=True).item()
    rho  = rho[str(dist)]['rho_scf']
    
    mol = gto.Mole()
    mol.build(atom     = [['F',(0.0000,0.0000,0.0000)],
                          ['H',(0.0000,0.0000, dist)]],
              basis    = 'sto-6g',
              symmetry = 'coov',
              spin     = 0,
              charge   = 0,
              verbose  = 4)
    mf       = scf.RHF(mol)
    mf       = scf.newton(mf)
    mf.kernel(rho)

    H_fci,mycas = get_hamiltonian_matrix(mol,mf,nf=1)
    S_fci       = get_spin_square_matrix(mol,mf,nf=1,nci=H_fci.shape[0])
    d1 = H_fci.shape[0]
    e1 = LA.eigh(H_fci)[0][0]

    H_fci,S_fci = project_along_irrep(mol,mf,mycas,nf=1,H_fci=H_fci,S_fci=S_fci)
    d2 = H_fci.shape[0]
    
    H_fci,S_fci = project_along_singlet(H_fci,S_fci)
    d3 = H_fci.shape[0]
    
    H_fci,S_fci,Proj,nqubit = pad_matrix(H_fci,S_fci)
    print("after padding, matrix size ...................",H_fci.shape[0])
    d4 = H_fci.shape[0]
    e4 = LA.eigh(H_fci)[0][0]

    H_op = matrix_to_qubit_operator(H_fci)
    H_op = matrix_to_qubit_operator(H_fci)
    P = matrix_to_qubit_operator(Proj)
    J = matrix_to_qubit_operator(np.dot(Proj,np.dot(H_fci,Proj)))

    write_to_file(H_op,0,'hf_%s_h.txt'%dist)
    write_to_file(P,0,'hf_%s_p.txt'%dist)
    write_to_file(J,0,'hf_%s_php.txt'%dist)

    info.append([d1,d2,d3,d4,e1,e4])

outf = open('hf_info.txt','w')
for d1,d2,d3,d4,e1,e4 in info:
    outf.write('%d %d %d %d %.12f %.12f \n' % (d1,d2,d3,d4,e1,e4))
outf.close()

#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Marios-MacBook-Pro.local', release='20.6.0', version='Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64', machine='x86_64')  Threads 1
Python 3.9.7 | packaged by conda-forge | (default, Sep  2 2021, 17:58:46) 
[Clang 11.1.0 ]
numpy 1.21.2  scipy 1.7.1
Date: Sun May  1 20:20:13 2022
PySCF version 1.7.6
PySCF path  /Users/mario/anaconda3/envs/caltech_entanglement/lib/python3.9/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 2
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry Coov subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 F      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr
[INPUT]  2 H      0.000000000000   0.000000000000   4.500000000000 AA    0.000000000000   0.000000000000   8.503767560543 Bohr

nuclear repulsion = 1.05835442184
point group symmetry = Coov
num. orbitals of irrep A1 = 4
num. orbitals of irrep E1x = 1
num. orbitals of irrep E1y = 1
number of shells = 4
number of NR pGTOs = 36
number of NR cGTOs = 6
basis = sto-6g
ecp = {}
CPU time:         9.53

WARN: Newton solver expects mo_coeff with mo_occ as initial guess but mo_occ is not found in the arguments.
      The given argument is treated as density matrix.

Freeze 0 electrons in irreps []
    10 free electrons in irreps A1 E1x E1y




******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> ********
method = SymAdaptedRHF-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpaf4amobp
max_memory 4000 MB (current use 0 MB)
******** <class 'pyscf.scf.hf_symm.SymAdaptedRHF'> Newton solver flags ********
SCF tol = 1e-09
conv_tol_grad = None
max. SCF cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpaf4amobp
max_cycle_inner = 12
max_stepsize = 0.05
ah_start_tol = 1e+09
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 40
ah_grad_trust_region = 2.5
kf_interval = 4
kf_trust_region = 5
canonicalization = True
max_memory 4000 MB (current use 0 MB)
Set conv_tol_grad to 3.16228e-05
HOMO (A1) = -0.167234340444411  LUMO (A1) = -0.0483184486891664
Initial guess E= -99.0027023161739  |g|= 1.34179e-11
macro= 0  E= -99.0027023161739  delta_E= -1.42109e-14  |g|= 1.34179e-11  1 KF 2 JK
Canonicalize SCF orbitals
macro X = 1  E=-99.0027023161739  |g|= 1.34179e-11  total 2 KF 4 JK
converged SCF energy = -99.0027023161739

******** <class 'pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF'> ********
CAS (4e+4e, 5o), ncore = 1, nvir = 0
max_cycle_macro = 50
max_cycle_micro = 4
conv_tol = 1e-07
conv_tol_grad = None
orbital rotation max_stepsize = 0.02
augmented hessian ah_max_cycle = 30
augmented hessian ah_conv_tol = 1e-12
augmented hessian ah_linear dependence = 1e-14
augmented hessian ah_level shift = 0
augmented hessian ah_start_tol = 2.5
augmented hessian ah_start_cycle = 3
augmented hessian ah_grad_trust_region = 3
kf_trust_region = 3
kf_interval = 4
ci_response_space = 4
ci_grad_trust_region = 3
with_dep4 0
natorb = False
canonicalization = True
sorting_mo_energy = False
ao2mo_level = 2
chkfile = /var/folders/7m/f464jvrs78n7m3djcnsxfxgr0000gn/T/tmpaf4amobp
max_memory 4000 MB (current use 0 MB)
internal_rotation = False
******** <class 'pyscf.fci.direct_spin1_symm.FCISolver'> ********
max. cycles = 50
conv_tol = 1e-08
davidson only = True
linear dependence = 1e-10
level shift = 0.001
max iter space = 12
max_memory 4000 MB
nroots = 1
pspace_size = 0
spin = None
CI wfn symmetry = None
Active space CI wfn symmetry = A1
CASCI E = -99.3842922953184  S^2 = 0.0000000
Set conv_tol_grad to 0.000316228
macro iter 1 (3 JK  1 micro), CASSCF E = -99.3842923037888  dE = -8.4704368e-09  S^2 = 0.0000000
               |grad[o]|=0.000469  |grad[c]|= 0.0008094865379269299  |ddm|=6.93e-06
macro iter 2 (1 JK  1 micro), CASSCF E = -99.3842923037888  dE = -2.8421709e-14  S^2 = 0.0000000
               |grad[o]|=2e-05  |grad[c]|= 4.7066442559533194e-07  |ddm|=    0
1-step CASSCF converged in 2 macro (4 JK 2 micro) steps
CASSCF canonicalization
Density matrix diagonal elements [1.99998932 2.         2.         1.00144421 0.99856648]
CASSCF energy = -99.3842923037888
CASCI E = -99.3842923037888  E(CI) = -24.7722866885594  S^2 = 0.0000000
Ground state energy (orig)  -99.38429229535043
Ground state energy (pad)  -99.38429229535043
after padding, matrix size ................... 8
